--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./Ex-2 -i ../res/uchar-gzip.nrrd -b 256 ---max 256
Data file:        cachegrind.out.90155
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr   ILmr  Dr          D1mr    DLmr   Dw          D1mw    DLmw    Bc         Bcm       Bi        Bim     
--------------------------------------------------------------------------------
1,674,179,168 48,392 8,549 571,050,778 919,572 66,278 326,087,846 527,026 352,329 95,064,559 3,579,212 1,499,931 263,592  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir          I1mr   ILmr  Dr          D1mr    DLmr   Dw         D1mw    DLmw    Bc         Bcm       Bi        Bim      file:function
--------------------------------------------------------------------------------
416,857,578     33     5 138,952,506   4,554      3 61,756,720     132      11 15,439,174     1,383         0       0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/histogram.h:ComputeHistogram::Operate()::{lambda()
216,148,100      4     3  54,037,025     108      1 38,597,875     215       0  7,719,575       232         0       0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/histogram.h:ComputeHistogram::DecodeBytes(std::basic_string_view<char, std::char_traits<char> > const&, unsigned long)
210,467,169 15,091 1,224  52,647,399 377,427    887 12,116,230  41,819   1,081 30,884,731 2,880,267 1,361,153 215,231  ???:???
146,671,925      2     1  38,597,875      56      0 46,317,450      82       0          0         0         0       0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/../hdr/Utility.h:double const& RkUtil::Clamp<double>(double const&, double const&, double const&)
115,793,625      0     0  54,037,025      95      0 23,158,725       0       0  7,719,575         5         0       0  /usr/include/c++/10/bits/stl_algobase.h:double const& std::min<double>(double const&, double const&)
114,127,299      0     0  54,037,025     136      0 23,158,725       0       0  7,719,575    66,811         0       0  /usr/include/c++/10/bits/stl_algobase.h:double const& std::max<double>(double const&, double const&)
108,074,050      5     2  38,597,875 121,003 18,787 30,878,300       0       0          0         0         0       0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/../hdr/Utility.h:unsigned char RkUtil::DecodeBytesSpcialized<unsigned char, void>(std::basic_string_view<char, std::char_traits<char> > const&, unsigned long)
 92,739,348      1     0  38,641,395     366      0 23,184,837       0       0          0         0         0       0  /usr/include/c++/10/bits/stl_vector.h:std::vector<unsigned int, std::allocator<unsigned int> >::operator[](unsigned long)
 84,915,325     14     2  38,597,875      26      0 23,158,725       0       0          0         0         0       0  /usr/include/c++/10/string_view:std::basic_string_view<char, std::char_traits<char> >::operator[](unsigned long) const
 61,756,696      5     2  30,878,348     208      0 15,439,174       0       0          0         0         0       0  /usr/include/c++/10/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const
 43,091,861  2,054    87   8,812,878  21,802      3  4,938,688   6,821      13  5,871,418   535,116    79,020  40,880  ???:inflate
 11,915,939     83    18   9,362,470 319,821 27,708  9,283,492 351,378 252,364  8,861,316    38,533         0       0  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  5,993,861      0     0           4       3      0  5,993,833  93,574  93,574  5,993,837        20         0       0  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
  5,774,254      3     1     965,013   1,105      0          0       0       0  1,922,145     1,457         0       0  ???:SpinLock::SpinLoop()
  2,689,039  2,198     6     502,350      48      0    650,097      48       0    265,948        28         1       1  /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp:boost::iostreams::detail::indirect_streambuf<boost::iostreams::basic_gzip_decompressor<std::allocator<char> >, std::char_traits<char>, std::allocator<char>, boost::iostreams::output>::overflow(int)
  2,568,034     16     7     851,651      27      0    574,508       0       0    216,181     2,458         0       0  /usr/include/boost/iostreams/filter/symmetric.hpp:long boost::iostreams::symmetric_filter<boost::iostreams::detail::zlib_decompressor_impl<std::allocator<char> >, std::allocator<char> >::write<boost::iostreams::detail::linked_streambuf<char, std::char_traits<char> > >(boost::iostreams::detail::linked_streambuf<char, std::char_traits<char> >&, char const*, long)
  2,009,456      3     3     472,814       0      0    502,364     484       0     59,102       120         0       0  /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp:boost::iostreams::detail::indirect_streambuf<boost::iostreams::basic_gzip_decompressor<std::allocator<char> >, std::char_traits<char>, std::allocator<char>, boost::iostreams::output>::sync_impl()

--------------------------------------------------------------------------------
-- Auto-annotated source: /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/histogram.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr  DLmr Dw         D1mw DLmw Bc        Bcm Bi Bim 

-- line 12 ----------------------------------------
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .  #include <boost/interprocess/file_mapping.hpp>
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .  #include "../hdr/command.h"
          .    .    .          .     .    .          .    .    .         .   .  .   .  #include "../hdr/config.h"
          .    .    .          .     .    .          .    .    .         .   .  .   .  #include "../hdr/Encoders.h"
          .    .    .          .     .    .          .    .    .         .   .  .   .  #include "../hdr/Utility.h"
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         44    3    3         12     0    0         12    0    0         0   0  0   0  class ComputeHistogram : public Task{
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .      // Ideally must be output bin type "-t <type>"
          .    .    .          .     .    .          .    .    .         .   .  .   .      using bins_type = std::vector<uint32_t>;/*RkUtil::AlignedContinuousMemory<>;*/
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .  public:
          8    1    1          0     0    0          5    0    0         0   0  0   0      explicit ComputeHistogram(const std::unique_ptr<RkConfig>& config)
         25    2    2          8     0    0          7    0    0         0   0  0   0          : m_Config(config) {
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          // exit if cannot operate. RAII.
         22    1    1          7     0    0          5    0    0         1   1  0   0          if (m_Config->data().bins < m_Config->data().max){
          .    .    .          .     .    .          .    .    .         .   .  .   .              throw std::runtime_error("bins must be >= max value to represent");
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          9    2    2          4     0    0          3    0    0         0   0  0   0          m_Bins = m_Config->data().bins;
          6    1    1          4     0    0          0    0    0         0   0  0   0      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         10    2    2          1     0    0          5    0    0         0   0  0   0      bool ParseInput() override{
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          8    1    1          2     0    0          3    0    0         0   0  0   0          const std::string& input_file_name = m_Config->data().input_file_name;
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          9    0    0          1     0    0          2    0    0         0   0  0   0          std::ifstream input_file_stream(input_file_name, std::ios::in);
          6    0    0          0     0    0          1    0    0         1   1  0   0          if (!input_file_stream.is_open()){
          .    .    .          .     .    .          .    .    .         .   .  .   .              std::cout << __FUNCTION__ << "input_file: " <<
          .    .    .          .     .    .          .    .    .         .   .  .   .                           input_file_name << " not found" << std::endl;
          .    .    .          .     .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        185    7    2         28     0    0         29    0    0        14   0  0   0          for (std::string line; std::getline(input_file_stream, line); ) {
          .    .    .          .     .    .          .    .    .         .   .  .   .              // strictly NRRD file will have a empty line to seperate header and data. validation must be done on other elemnst as well
         70    0    0          0     0    0         14    0    0        14   3  0   0              if (line.empty())
          7    1    1          0     0    0          1    0    0         1   1  0   0                  break;
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         78    1    1          0     0    0         13    0    0         0   0  0   0              std::vector<std::string> vals = RkUtil::Split(line, ':');
         91    0    0          0     0    0         13    0    0        13   4  0   0              if (vals.size() != 2)
          4    0    0          0     0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        297    3    2          0     0    0         66    0    0        11   4  0   0              if (RkUtil::str_toupper(vals[0]) == "TYPE"){
         27    2    2          2     0    0          7    1    0         0   0  0   0                  m_Type = RkUtil::PayLoadType[RkUtil::str_toupper(vals[1])];
          2    0    0          0     0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .     .    .          .    .    .         .   .  .   .              }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        270    5    3          0     0    0         60    0    0        10   4  0   0              if (RkUtil::str_toupper(vals[0]) == "DIMENSION"){
          .    .    .          .     .    .          .    .    .         .   .  .   .                  try {
         11    0    0          1     0    0          3    0    0         0   0  0   0                      m_Dimension = std::stoi(vals[1]);
          .    .    .          .     .    .          .    .    .         .   .  .   .                  }catch (...) {
          .    .    .          .     .    .          .    .    .         .   .  .   .                      std::cerr << "Invalid dimensions: " << vals[1] << std::endl;
          .    .    .          .     .    .          .    .    .         .   .  .   .                      m_Dimension = 0;
          .    .    .          .     .    .          .    .    .         .   .  .   .                  };
          2    1    0          0     0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .     .    .          .    .    .         .   .  .   .              }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        243   11    3          0     0    0         54    0    0         9   4  0   0              if (RkUtil::str_toupper(vals[0]) == "SIZES"){
          .    .    .          .     .    .          .    .    .         .   .  .   .                  // No need const & as copy elision will happen.
         15    0    0          0     0    0          3    0    0         0   0  0   0                  std::vector<std::string> s = RkUtil::Split(vals[1], ' ');
         19    2    2          0     0    0          5    0    0         0   0  0   0                  s.resize(MAX_DIMENSIONS, "1");
        149    4    2         37     0    0         41    0    0         0   0  0   0                  std::generate(m_Sizes.begin(), m_Sizes.end(), [n = 0, s]() mutable{
         16    0    0          0     0    0         16    0    0         0   0  0   0                      std::size_t v = 0;
          .    .    .          .     .    .          .    .    .         .   .  .   .                      try{
        240    1    1         32     0    0         64    0    0         0   0  0   0                          v = std::stoi(s[n++]);
          .    .    .          .     .    .          .    .    .         .   .  .   .                      }catch(...){
          .    .    .          .     .    .          .    .    .         .   .  .   .                          v = 1;
          .    .    .          .     .    .          .    .    .         .   .  .   .                      }
         32    1    1         16     0    0          0    0    0         0   0  0   0                      return v;
         32    0    0         32     0    0          0    0    0         0   0  0   0                  });
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          1    0    0          0     0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .     .    .          .    .    .         .   .  .   .              }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        216   11    3          0     0    0         48    0    0         8   6  0   0              if (RkUtil::str_toupper(vals[0]) == "ENCODING"){
         25    2    2          0     0    0          7    0    0         0   0  0   0                  auto itr = RkEncoders::Encoders.find(RkUtil::str_toupper(vals[1]));
         10    1    1          0     0    0          3    0    0         1   1  0   0                  if (itr == RkEncoders::Encoders.end()){
          .    .    .          .     .    .          .    .    .         .   .  .   .                      std::cerr << "Invalid encoding not (yet) supported" << std::endl;
          .    .    .          .     .    .          .    .    .         .   .  .   .                      return false;
          .    .    .          .     .    .          .    .    .         .   .  .   .                  }
         97    2    2          1     0    0         15    0    0        20  11  0   0                  m_Encoder = itr->second;
          .    .    .          .     .    .          .    .    .         .   .  .   .                  continue;
          .    .    .          .     .    .          .    .    .         .   .  .   .              }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          // Since product obtained might be huge lets parallelize.
         15    2    1          3     0    0          4    1    0         0   0  0   0          m_DataSize = RkUtil::parallel_multiply(m_Sizes.begin(), m_Sizes.end());
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          4    0    0          2     0    0          0    0    0         1   1  0   0          if (m_DataSize <= 0){
          .    .    .          .     .    .          .    .    .         .   .  .   .              std::cout << "Empty nrrd data file (not header file) so bail out" << std::endl;
          .    .    .          .     .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         13    3    3          2     0    0          2    0    0         1   1  1   1          if (!m_Encoder->Parse(input_file_stream, input_file_name,
         12    1    1          8     4    1          0    0    0         0   0  0   0                                (m_DataSize * RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]), m_DecompressedData)){
          .    .    .          .     .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          // return true only if input data is fully validated
          1    0    0          0     0    0          0    0    0         0   0  0   0          return true;
          9    1    1          6     2    1          0    0    0         1   1  0   0      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         10    2    2          1     0    0          5    0    0         0   0  0   0      bool Operate() override{
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          try{
          .    .    .          .     .    .          .    .    .         .   .  .   .              /*
          .    .    .          .     .    .          .    .    .         .   .  .   .               * Not good idea to Operate() while Parse() in action because
          .    .    .          .     .    .          .    .    .         .   .  .   .               * # if mid data is corrupted Operate() on previous data goes stale
          .    .    .          .     .    .          .    .    .         .   .  .   .               * Not a good idea to read the file with multiple threads as disk reading HW needle
          .    .    .          .     .    .          .    .    .         .   .  .   .               * is still one which might have to jump sectors and worsen performance.
          .    .    .          .     .    .          .    .    .         .   .  .   .               * or memory map the whole file will exhaust memory if file is too large (can shrink though).
          .    .    .          .     .    .          .    .    .         .   .  .   .              */
         33    4    2          3     0    0         10    1    1         2   1  0   0              for (std::string& slice : m_DecompressedData){
          7    0    0          2     1    1          2    0    0         0   0  0   0                  std::size_t individual_buffer_size = (slice.size() / NO_OF_CORES);
          1    1    1          0     0    0          1    0    0         0   0  0   0                  boost::interprocess::offset_t offset = 0;
          4    0    0          1     0    0          2    0    0         0   0  0   0                  const std::size_t datasize = slice.size();
        125    4    1         62     2    0         13    0    0        13   2  0   0                  for(uint i = 1; i <= NO_OF_CORES; i++, offset += individual_buffer_size){
         48    3    1         24     0    0          0    0    0        12   3  0   0                      if(i == NO_OF_CORES){
          8    0    0          3     0    0          1    0    0         0   0  0   0                          individual_buffer_size = datasize - ((i-1) * individual_buffer_size);
          .    .    .          .     .    .          .    .    .         .   .  .   .                      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         72    2    1         24     0    0         24    0    0         0   0  0   0                      const char* start = (slice.data() + offset);
         72    0    0         24     0    0         12    0    0         0   0  0   0                      std::string_view tmp(start, individual_buffer_size);
         96    2    1         36     3    2         36    0    0         0   0  0   0                      const auto min = m_Config->data().min;
         96    0    0         36     0    0         36    0    0         0   0  0   0                      const auto max = m_Config->data().max;
 30,878,480    5    1 30,878,336   271    0         72   12   11         0   0  0   0                      auto fu = std::async(std::launch::async, [min, max, this, data = std::move(tmp)]() mutable{
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        156    0    0         24     2    0         36    0    0         0   0  0   0                          bins_type hist(m_Bins);
154,391,632   12    2 38,597,899   300    0 15,439,174    3    0 7,719,587 509  0   0                          for (int idx = 0; idx < data.size(); idx += RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]) {
 69,476,175    8    1 15,439,150    39    0 15,439,150   96    0         0   0  0   0                              auto val = DecodeBytes(data, idx);
          .    .    .          .     .    .          .    .    .         .   .  .   .                              // TODO: caution!!.
          .    .    .          .     .    .          .    .    .         .   .  .   .                              // strictly validate for extents because hist[] is pre allocated based on bins.
          .    .    .          .     .    .          .    .    .         .   .  .   .                              // must implement minmax
 69,476,175    3    0 23,158,725   118    0 15,439,150   21    0         0   0  0   0                              val = RkUtil::Clamp(min, val, max);
 92,634,900    5    1 30,878,300 3,823    3 15,439,150    0    0 7,719,575 871  0   0                              hist[val] += 1;
          .    .    .          .     .    .          .    .    .         .   .  .   .                          }
         12    0    0          0     0    0          0    0    0         0   0  0   0                          return hist;
        300    3    2        132     1    0         84    1    0        12   3  0   0                      });
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         96    2    0         12     0    0         24    0    0         0   0  0   0                      m_Futures.push_back(std::move(fu));
          .    .    .          .     .    .          .    .    .         .   .  .   .                  }
          .    .    .          .     .    .          .    .    .         .   .  .   .              }
          .    .    .          .     .    .          .    .    .         .   .  .   .          }catch(std::exception& ex){
          .    .    .          .     .    .          .    .    .         .   .  .   .              std::cout << "exception occured while computing histogram: why?: " << ex.what() << std::endl;
          .    .    .          .     .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          1    0    0          0     0    0          0    0    0         0   0  0   0          return true;
          9    2    2          6     2    0          0    0    0         1   1  0   0      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          9    1    1          1     0    0          4    0    0         0   0  0   0      void WriteOutput() {
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          /*
          .    .    .          .     .    .          .    .    .         .   .  .   .           * DESIGN NOTE:
          .    .    .          .     .    .          .    .    .         .   .  .   .           * As this exercise is latency sensitive than memory sensitive.
          .    .    .          .     .    .          .    .    .         .   .  .   .           * threads work on independent memory. sharing the same memory and using atomics or mutex will slow down.
          .    .    .          .     .    .          .    .    .         .   .  .   .           * atomics is lock free but not wait free.
          .    .    .          .     .    .          .    .    .         .   .  .   .           * Eg:
          .    .    .          .     .    .          .    .    .         .   .  .   .           *  |   |   |   |
-- line 173 ----------------------------------------
-- line 184 ----------------------------------------
          .    .    .          .     .    .          .    .    .         .   .  .   .           *  * (&&) above mean multithreading.
          .    .    .          .     .    .          .    .    .         .   .  .   .           *
          .    .    .          .     .    .          .    .    .         .   .  .   .           * If GPU available vectorization (tensors) with a ton of threads litreally one (grids/blocks)thread per
          .    .    .          .     .    .          .    .    .         .   .  .   .           * pixel shall be spawned with CUDA/OpenCL/Metal APIs or with SIMD instructions(Single instruction, multiple data )
          .    .    .          .     .    .          .    .    .         .   .  .   .           *
          .    .    .          .     .    .          .    .    .         .   .  .   .           * Maybe I will submit another solution in '*.cu' with only the kernel function later.
          .    .    .          .     .    .          .    .    .         .   .  .   .          */
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          6    1    1          0     0    0          2    0    0         0   0  0   0          bins_type ret;
         95   11    0         12     0    0         12    0    0        12   2  0   0          while(!m_Futures.empty()){
         60   12    1         12     0    0         24    0    0         0   0  0   0              auto& fu1 = m_Futures.front();
        156   15    1         12     0    0         36    0    0         0   0  0   0              ret = fu1.get();
         48    0    0         12     0    0         12    0    0         0   0  0   0              m_Futures.pop_front();
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         72    0    0         12     0    0         12    0    0        12   1  0   0              if (m_Futures.empty())
          1    0    0          0     0    0          0    0    0         0   0  0   0                  break;
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         66   11    1          0     0    0         22    0    0         0   0  0   0              std::promise<bins_type> merge_promise;
         88    0    0          0     0    0         22    0    0         0   0  0   0              std::future<bins_type> merge_future = merge_promise.get_future();
      6,996   34    1      6,017     2    0        341    8    0         0   0  0   0              auto mergefu = std::async(std::launch::async, [this, first = std::move(ret), second = std::move(merge_future)]() mutable{
          .    .    .          .     .    .          .    .    .         .   .  .   .  
        143    8    1         22     1    0         33    0    0         0   0  0   0                  bins_type ret(m_Bins);
         99   16    2         11     0    0         22    0    0         0   0  0   0                  auto other = second.get();
        110    2    0         11     0    0         22    0    0        11   0  0   0                  assert(first.size() == other.size());
     16,951    8    1      8,470     1    0         11    0    0     2,827  18  0   0                  for (int i = 0; i < m_Bins; ++i){
     64,768    9    1     19,712   300   24     11,264   44    0         0   0  0   0                      ret[i] = first[i] + other[i];
          .    .    .          .     .    .          .    .    .         .   .  .   .                  }
         22    0    0          0     0    0          0    0    0         0   0  0   0                  return ret;
        330   17    2         77     0    0         66    0    0        11   0  0   0              });
          .    .    .          .     .    .          .    .    .         .   .  .   .  
         88   11    1         11     0    0         22    0    0         0   0  0   0              m_Futures.push_back(std::move(mergefu));
         55    0    0         11     0    0         22    0    0         0   0  0   0              auto& fu2 = m_Futures.front();
        143   10    1         11     0    0         33    0    0         0   0  0   0              merge_promise.set_value(fu2.get());
         44   11    1         11     0    0         11    0    0         0   0  0   0              m_Futures.pop_front();
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          9    1    1          1     0    0          2    0    0         0   0  0   0          m_Output = std::move(ret);
         15    2    2          2     0    0          4    0    0         0   0  0   0          std::ofstream output(m_Config->data().output_file_name);
      3,083    1    1        770     0    0        258    0    0       257   2  0   0          for (int i = 0; i < m_Output.size(); ++i){
      2,048    0    0        512     0    0        512    0    0         0   0  0   0              const auto& c = m_Output[i];
      6,144    2    2        768    17    0      1,536    0    0         0   0  0   0              output << "(" << i << ", " << c << ")" << '\n';
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          3    0    0          0     0    0          1    0    0         0   0  0   0          output.close();
          .    .    .          .     .    .          .    .    .         .   .  .   .  #if 0
          .    .    .          .     .    .          .    .    .         .   .  .   .          const std::string tmp = std::string("subl ") + std::string(m_Config->data().output_file_name);
          .    .    .          .     .    .          .    .    .         .   .  .   .          system(tmp.data());
          .    .    .          .     .    .          .    .    .         .   .  .   .  #endif
          7    1    0          5     1    0          0    0    0         1   1  0   0      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
 54,037,025    1    1          0     0    0 30,878,300    0    0         0   0  0   0      double DecodeBytes(const std::string_view& data, std::size_t index){
          .    .    .          .     .    .          .    .    .         .   .  .   .  
 61,756,600    1    1 23,158,725    64    1          0    0    0 7,719,575 232  0   0          switch (RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]) {
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          case 1:         //uchar
 69,476,175    2    1 15,439,150     0    0  7,719,575  215    0         0   0  0   0              return RkUtil::DecodeBytesSpcialized<uint8_t>(data, index);
          .    .    .          .     .    .          .    .    .         .   .  .   .              break;
          .    .    .          .     .    .          .    .    .         .   .  .   .          case 2:         // short
          .    .    .          .     .    .          .    .    .         .   .  .   .              return RkUtil::DecodeBytesSpcialized<int16_t>(data, index);
          .    .    .          .     .    .          .    .    .         .   .  .   .              break;
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          return 0.0;
 30,878,300    0    0 15,439,150    44    0          0    0    0         0   0  0   0      }
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .  #ifdef RUN_CATCH
          .    .    .          .     .    .          .    .    .         .   .  .   .      std::size_t OutputVal(){
          .    .    .          .     .    .          .    .    .         .   .  .   .  
          .    .    .          .     .    .          .    .    .         .   .  .   .          std::size_t ret = 0;
          .    .    .          .     .    .          .    .    .         .   .  .   .          for (int i = 0; i < m_Output.size(); ++i){
          .    .    .          .     .    .          .    .    .         .   .  .   .              ret += m_Output[i];
          .    .    .          .     .    .          .    .    .         .   .  .   .          }
-- line 254 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc        Bcm    Bi Bim 

-- line 222 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .     *
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  This is the simple classic generic implementation.  It will work on
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  temporary expressions, since they are only evaluated once, unlike a
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  preprocessor macro.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX14_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline const _Tp&
38,598,380   14    2          0    0    0 23,159,028    0    0         0      0  0   0      min(const _Tp& __a, const _Tp& __b)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .        //return __b < __a ? __b : __a;
46,318,056   18    2 30,878,704   95    0          0    0    0 7,719,676     26  0   0        if (__b < __a)
15,439,150    0    0  7,719,575    0    0          0    0    0         0      0  0   0  	return __b;
       101    0    0        101    0    0          0    0    0         0      0  0   0        return __a;
15,439,352    0    0 15,439,352    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief This does what you think it does.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup sorting_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __a  A thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __b  Another thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The greater of the parameters.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  This is the simple classic generic implementation.  It will work on
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  temporary expressions, since they are only evaluated once, unlike a
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  preprocessor macro.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX14_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline const _Tp&
38,598,065    4    1          0    0    0 23,158,839    0    0         0      0  0   0      max(const _Tp& __a, const _Tp& __b)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .        //return  __a < __b ? __b : __a;
46,317,678    0    0 30,878,452  136    0          0    0    0 7,719,613 66,829  0   0        if (__a < __b)
12,106,534    7    1  6,053,267    0    0          0    0    0         0      0  0   0  	return __b;
 1,666,346    1    0  1,666,346    0    0          0    0    0         0      0  0   0        return __a;
15,439,226    0    0 15,439,226    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief This does what you think it does.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup sorting_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __a  A thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __b  Another thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __comp  A @link comparison_functors comparison functor@endlink.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The lesser of the parameters.
-- line 270 ----------------------------------------
-- line 305 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        return __a;
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Fallback implementation of the function in bits/stl_iterator.h used to
         .    .    .          .    .    .          .    .    .         .      .  .   .    // remove the __normal_iterator wrapper. See copy, fill, ...
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Iterator>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _Iterator
       852    6    1          0    0    0        426    0    0         0      0  0   0      __niter_base(_Iterator __it)
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
       639    0    0        639    0    0          0    0    0         0      0  0   0      { return __it; }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Reverse the __niter_base transformation to get a
         .    .    .          .    .    .          .    .    .         .      .  .   .    // __normal_iterator back again (this assumes that __normal_iterator
         .    .    .          .    .    .          .    .    .         .      .  .   .    // is only used to wrap random access iterators, like pointers).
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _From, typename _To>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _From
         .    .    .          .    .    .          .    .    .         .      .  .   .      __niter_wrap(_From __from, _To __res)
-- line 323 ----------------------------------------
-- line 860 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        for (; __first != __last; ++__first)
         .    .    .          .    .    .          .    .    .         .      .  .   .  	*__first = __value;
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _ForwardIterator, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline typename
         .    .    .          .    .    .          .    .    .         .      .  .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
       138   13    1          0    0    0         92    0    0         0      0  0   0      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _Tp& __value)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
        69    0    0         46    0    0         23    0    0         0      0  0   0        const _Tp __tmp = __value;
    29,509   15    0     17,710    0    0          0    0    0     5,911     25  0   0        for (; __first != __last; ++__first)
    17,664    0    0     11,776    0    0      5,888  313  302         0      0  0   0  	*__first = __tmp;
        69    0    0         46    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Specialization: for char types we can use memset.
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline typename
         .    .    .          .    .    .          .    .    .         .      .  .   .      __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
-- line 882 ----------------------------------------
-- line 905 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .      void
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _VTp&);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _FIte, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline void
       161    8    0          0    0    0         92    0    0         0      0  0   0      __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
       207    0    0        115    0    0         23    0    0         0      0  0   0      { std::__fill_a1(__first, __last, __value); }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      void
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	     const _Tp&);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
-- line 922 ----------------------------------------
-- line 947 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR int
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(int __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(unsigned __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned long
       161   13    1         69    0    0         46    0    0         0      0  0   0    __size_to_integer(unsigned long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR long long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(long long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned long long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(unsigned long long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .  #if defined(__GLIBCXX_TYPE_INT_N_0)
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
-- line 963 ----------------------------------------
-- line 1046 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
         .    .    .          .    .    .          .    .    .         .      .  .   .  #endif
         .    .    .          .    .    .          .    .    .         .      .  .   .        return __fill_n_a1(__first, __n, __value);
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _OutputIterator, typename _Size, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _OutputIterator
       161    0    0          0    0    0         92    0    0         0      0  0   0      __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	       std::random_access_iterator_tag)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .         .      .  .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
         .    .    .          .    .    .          .    .    .         .      .  .   .  #endif
        46    0    0         23    0    0          0    0    0        23      1  0   0        if (__n <= 0)
         .    .    .          .    .    .          .    .    .         .      .  .   .  	return __first;
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_requires_can_increment(__first, __n);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
       207   13    0         92    0    0         23    0    0         0      0  0   0        std::__fill_a(__first, __first + __n, __value);
        92    0    0         46    0    0          0    0    0         0      0  0   0        return __first + __n;
        46    0    0         46    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief Fills the range [first,first+n) with copies of value.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup mutating_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __first  An output iterator.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __n      The count of copies to perform.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __value  A reference-to-const of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The iterator at first+n.
-- line 1075 ----------------------------------------
-- line 1081 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  If @p __n is negative, the function does nothing.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .    .    .          .    .    .          .    .    .         .      .  .   .    // DR 865. More algorithms that throw away information
         .    .    .          .    .    .          .    .    .         .      .  .   .    // DR 426. search_n(), fill_n(), and generate_n() with negative n
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _OI, typename _Size, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _OI
       161    0    0          0    0    0         92    0    0         0      0  0   0      fill_n(_OI __first, _Size __n, const _Tp& __value)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .  
       207    7    0         69    0    0         46    0    0         0      0  0   0        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
        69    0    0          0    0    0         23    0    0         0      0  0   0  			       std::__iterator_category(__first));
        46    0    0         46    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<bool _BoolType>
         .    .    .          .    .    .          .    .    .         .      .  .   .      struct __equal
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        template<typename _II1, typename _II2>
         .    .    .          .    .    .          .    .    .         .      .  .   .  	_GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .  	static bool
         .    .    .          .    .    .          .    .    .         .      .  .   .  	equal(_II1 __first1, _II1 __last1, _II2 __first2)
-- line 1104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp
--------------------------------------------------------------------------------
Ir      I1mr  ILmr Dr      D1mr  DLmr Dw      D1mw DLmw Bc      Bcm Bi Bim 

-- line 42 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .   .  .   .  #include <boost/iostreams/detail/config/disable_warnings.hpp>  // MSVC, BCC 5.x
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  namespace boost { namespace iostreams { namespace detail {
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //
      .     .    .       .     .    .       .    .    .       .   .  .   .  // Description: The implementation of basic_streambuf used by chains.
      .     .    .       .     .    .       .    .    .       .   .  .   .  //
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     66     5    5      18     0    0      18    0    0       0   0  0   0  class indirect_streambuf
      .     .    .       .     .    .       .    .    .       .   .  .   .      : public linked_streambuf<BOOST_DEDUCED_TYPENAME char_type_of<T>::type, Tr>
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .  public:
      .     .    .       .     .    .       .    .    .       .   .  .   .      typedef typename char_type_of<T>::type                    char_type;
      .     .    .       .     .    .       .    .    .       .   .  .   .      BOOST_IOSTREAMS_STREAMBUF_TYPEDEFS(Tr)
      .     .    .       .     .    .       .    .    .       .   .  .   .  private:
      .     .    .       .     .    .       .    .    .       .   .  .   .      typedef typename category_of<T>::type                     category;
      .     .    .       .     .    .       .    .    .       .   .  .   .      typedef concept_adapter<T>                                wrapper;
-- line 58 ----------------------------------------
-- line 95 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .   .  .   .      void set_next(streambuf_type* next);
      .     .    .       .     .    .       .    .    .       .   .  .   .      void close_impl(BOOST_IOS::openmode m);
      .     .    .       .     .    .       .    .    .       .   .  .   .      const boost::core::typeinfo& component_type() const { return BOOST_CORE_TYPEID(T); }
      .     .    .       .     .    .       .    .    .       .   .  .   .      void* component_impl() { return component(); }
      .     .    .       .     .    .       .    .    .       .   .  .   .  private:
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      //----------Accessor functions--------------------------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
345,906    42    2  94,338     0    0  94,338    0    0       0   0  0   0      wrapper& obj() { return *storage_; }
251,480    44    1 125,740     0    0  62,870    0    0       0   0  0   0      streambuf_type* next() const { return next_; }
      .     .    .       .     .    .       .    .    .       .   .  .   .      buffer_type& in() { return buffer_.first(); }
691,636 1,885    1 188,628     0    0 188,628    0    0       0   0  0   0      buffer_type& out() { return buffer_.second(); }
     14     2    2       4     0    0       4    0    0       0   0  0   0      bool can_read() const { return is_convertible<Mode, input>::value; }
     28     3    3       8     0    0       8    0    0       0   0  0   0      bool can_write() const { return is_convertible<Mode, output>::value; }
691,614    10    3 251,496 2,240    0 125,748    0    0       0   0  0   0      bool output_buffered() const { return (flags_ & f_output_buffered) != 0; }
220,073    10    3  62,878     0    0  62,878    0    0       0   0  0   0      bool shared_buffer() const { return is_convertible<Mode, seekable>::value || is_convertible<Mode, dual_seekable>::value; }
      .     .    .       .     .    .       .    .    .       .   .  .   .      void set_flags(int f) { flags_ = f; }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      //----------State changing functions--------------------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      virtual void init_get_area();
      .     .    .       .     .    .       .    .    .       .   .  .   .      virtual void init_put_area();
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      //----------Utility function----------------------------------------------//
-- line 118 ----------------------------------------
-- line 138 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .   .  .   .      >                           buffer_;
      .     .    .       .     .    .       .    .    .       .   .  .   .      std::streamsize             pback_size_;
      .     .    .       .     .    .       .    .    .       .   .  .   .      int                         flags_;
      .     .    .       .     .    .       .    .    .       .   .  .   .  };
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //--------------Implementation of indirect_streambuf--------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     18     2    2       0     0    0       9    0    0       0   0  0   0  indirect_streambuf<T, Tr, Alloc, Mode>::indirect_streambuf()
     72     7    7      30     0    0      21    1    0       0   0  0   0      : next_(0), pback_size_(0), flags_(f_auto_close) { }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //--------------Implementation of open, is_open and close---------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     24     2    2       2     0    0      14    1    0       0   0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::open
      .     .    .       .     .    .       .    .    .       .   .  .   .      (const T& t, std::streamsize buffer_size, std::streamsize pback_size)
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      using namespace std;
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      // Normalize buffer sizes.
      2     0    0       0     0    0       2    0    0       0   0  0   0      buffer_size =
      6     1    1       4     0    0       0    0    0       2   2  0   0          (buffer_size != -1) ?
      .     .    .       .     .    .       .    .    .       .   .  .   .          buffer_size :
      .     .    .       .     .    .       .    .    .       .   .  .   .          iostreams::optimal_buffer_size(t);
      2     0    0       0     0    0       2    0    0       0   0  0   0      pback_size =
     10     2    2       4     0    0       0    0    0       2   0  0   0          (pback_size != -1) ?
      2     0    0       0     0    0       0    0    0       0   0  0   0          pback_size :
      .     .    .       .     .    .       .    .    .       .   .  .   .          default_pback_buffer_size;
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      // Construct input buffer.
     10     0    0       2     0    0       2    0    0       2   2  0   0      if (can_read()) {
      .     .    .       .     .    .       .    .    .       .   .  .   .          pback_size_ = (std::max)(std::streamsize(2), pback_size); // STLPort needs 2.
      .     .    .       .     .    .       .    .    .       .   .  .   .          std::streamsize size =
      .     .    .       .     .    .       .    .    .       .   .  .   .              pback_size_ +
      .     .    .       .     .    .       .    .    .       .   .  .   .              ( buffer_size ? buffer_size: std::streamsize(1) );
      .     .    .       .     .    .       .    .    .       .   .  .   .          in().resize(static_cast<int>(size));
      .     .    .       .     .    .       .    .    .       .   .  .   .          if (!shared_buffer())
      .     .    .       .     .    .       .    .    .       .   .  .   .              init_get_area();
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .      // Construct output buffer.
     30     3    3       4     0    0       4    0    0       6   1  0   0      if (can_write() && !shared_buffer()) {
      4     0    0       2     0    0       0    0    0       2   0  0   0          if (buffer_size != std::streamsize(0))
     18     2    2       4     0    0       4    0    0       0   0  0   0              out().resize(static_cast<int>(buffer_size));
     14     0    0       8     2    0       2    0    0       0   0  2   2          init_put_area();
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
     25     2    2       4     0    0       5    0    0       0   0  0   0      storage_.reset(wrapper(t));
     12     1    1       6     0    0       2    0    0       0   0  0   0      flags_ |= f_open;
     22     1    1       4     0    0       2    0    0       6   1  0   0      if (can_write() && buffer_size > 1)
     12     1    1       6     0    0       2    0    0       0   0  0   0          flags_ |= f_output_buffered;
      8     0    0       2     0    0       2    0    0       0   0  0   0      this->set_true_eof(false);
      6     1    1       2     0    0       2    0    0       0   0  0   0      this->set_needs_close();
     14     0    0      10     0    0       0    0    0       2   1  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     20     5    5       0     0    0      10    0    0       0   0  0   0  inline bool indirect_streambuf<T, Tr, Alloc, Mode>::is_open() const
     35     2    2      20     1    0       0    0    0       0   0  0   0  { return (flags_ & f_open) != 0; }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .   .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::close()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      using namespace std;
      .     .    .       .     .    .       .    .    .       .   .  .   .      base_type* self = this;
      .     .    .       .     .    .       .    .    .       .   .  .   .      detail::execute_all(
      .     .    .       .     .    .       .    .    .       .   .  .   .          detail::call_member_close(*self, BOOST_IOS::in),
      .     .    .       .     .    .       .    .    .       .   .  .   .          detail::call_member_close(*self, BOOST_IOS::out),
      .     .    .       .     .    .       .    .    .       .   .  .   .          detail::call_reset(storage_),
      .     .    .       .     .    .       .    .    .       .   .  .   .          detail::clear_flags(flags_)
      .     .    .       .     .    .       .    .    .       .   .  .   .      );
      .     .    .       .     .    .       .    .    .       .   .  .   .  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      8     2    2       0     0    0       4    0    0       0   0  0   0  bool indirect_streambuf<T, Tr, Alloc, Mode>::auto_close() const
     14     0    0       8     0    0       0    0    0       0   0  0   0  { return (flags_ & f_auto_close) != 0; }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     12     0    0       0     0    0       6    0    0       0   0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::set_auto_close(bool close)
     24     2    2      12     1    0       2    0    0       2   2  0   0  { flags_ = (flags_ & ~f_auto_close) | (close ? f_auto_close : 0); }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //--------------Implementation virtual functions------------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  #ifndef BOOST_IOSTREAMS_NO_LOCALE
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .   .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::imbue(const std::locale& loc)
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      if (is_open()) {
-- line 224 ----------------------------------------
-- line 275 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .   .  .   .          return traits_type::not_eof(c);
      .     .    .       .     .    .       .    .    .       .   .  .   .      } else {
      .     .    .       .     .    .       .    .    .       .   .  .   .          boost::throw_exception(bad_putback());
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      .     .    .       .     .    .       .    .    .       .   .  .   .  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .   .  .   .  typename indirect_streambuf<T, Tr, Alloc, Mode>::int_type
314,350   153    3  31,435     0    0 157,175    0    0       0   0  0   0  indirect_streambuf<T, Tr, Alloc, Mode>::overflow(int_type c)
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
471,523 2,018    3  62,870     0    0  62,870    5    0 125,738  13  0   0      if ( (output_buffered() && pptr() == 0) ||
 94,299     0    0  31,433     0    0  31,433    0    0       0   0  0   0           (shared_buffer() && gptr() != 0) )
      .     .    .       .     .    .       .    .    .       .   .  .   .      {
     14     0    0       8     1    0       2    0    0       0   0  2   2          init_put_area();
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
314,350    48    2       0     0    0  94,305    0    0  31,435   1  0   0      if (!traits_type::eq_int_type(c, traits_type::eof())) {
157,175     0    0  31,435     0    0  31,435    0    0  31,435   0  0   0          if (output_buffered()) {
345,785     1    1  62,870     0    0  62,870    0    0  31,435   2  0   0              if (pptr() == epptr()) {
 94,299     0    0  31,433     0    0  31,433    0    0       0   0  0   0                  sync_impl();
345,763    41    0  62,866    57    0  62,866    0    0  31,433  13  0   0                  if (pptr() == epptr())
      .     .    .       .     .    .       .    .    .       .   .  .   .                      return traits_type::eof();
      .     .    .       .     .    .       .    .    .       .   .  .   .              }
251,480     4    3  31,435     0    0  94,305   48    0       0   0  0   0              *pptr() = traits_type::to_char_type(c);
157,175     0    0  31,435     0    0  31,435    0    0       0   0  0   0              pbump(1);
      .     .    .       .     .    .       .    .    .       .   .  .   .          } else {
      .     .    .       .     .    .       .    .    .       .   .  .   .              char_type d = traits_type::to_char_type(c);
      .     .    .       .     .    .       .    .    .       .   .  .   .              if (obj().write(&d, 1, next_) != 1)
      .     .    .       .     .    .       .    .    .       .   .  .   .                  return traits_type::eof();
      .     .    .       .     .    .       .    .    .       .   .  .   .          }
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
125,740    29    2       0     0    0  31,435    0    0       0   0  0   0      return traits_type::not_eof(c);
188,610     0    0 157,175     0    0       0    0    0  31,435  13  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     48     3    3       0     0    0      24    0    0       0   0  0   0  int indirect_streambuf<T, Tr, Alloc, Mode>::sync()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      try { // sync() is no-throw.
     24     1    1       8     0    0       8    0    0       0   0  0   0          sync_impl();
     72     0    0      24     0    0      16    0    0       0   0  0   0          obj().flush(next_);
      8     0    0       0     0    0       0    0    0       0   0  0   0          return 0;
      .     .    .       .     .    .       .    .    .       .   .  .   .      } catch (...) { return -1; }
     40     2    2      24     0    0       0    0    0       0   0  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .   .  .   .  bool indirect_streambuf<T, Tr, Alloc, Mode>::strict_sync()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      try { // sync() is no-throw.
      .     .    .       .     .    .       .    .    .       .   .  .   .          sync_impl();
      .     .    .       .     .    .       .    .    .       .   .  .   .          return obj().flush(next_);
      .     .    .       .     .    .       .    .    .       .   .  .   .      } catch (...) { return false; }
-- line 324 ----------------------------------------
-- line 370 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .   .  .   .      else {
      .     .    .       .     .    .       .    .    .       .   .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      .     .    .       .     .    .       .    .    .       .   .  .   .      return obj().seek(off, way, which, next_);
      .     .    .       .     .    .       .    .    .       .   .  .   .  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     10     1    1       0     0    0       6    0    0       0   0  0   0  inline void indirect_streambuf<T, Tr, Alloc, Mode>::set_next
      .     .    .       .     .    .       .    .    .       .   .  .   .      (streambuf_type* next)
     12     1    1       8     0    0       2    0    0       0   0  0   0  { next_ = next; }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     24     2    2       0     0    0      12    0    0       0   0  0   0  inline void indirect_streambuf<T, Tr, Alloc, Mode>::close_impl
      .     .    .       .     .    .       .    .    .       .   .  .   .      (BOOST_IOS::openmode which)
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      if (which == BOOST_IOS::in && is_convertible<Mode, input>::value) {
      .     .    .       .     .    .       .    .    .       .   .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      8     0    0       4     0    0       0    0    0       4   2  0   0      if (which == BOOST_IOS::out && is_convertible<Mode, output>::value) {
     14     0    0       8     0    0       2    0    0       0   0  2   2          sync();
     10     0    0       2     0    0       2    0    0       0   0  0   0          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      4     1    1       2     0    0       0    0    0       2   1  0   0      if ( !is_convertible<category, dual_use>::value ||
      .     .    .       .     .    .       .    .    .       .   .  .   .           is_convertible<Mode, input>::value == (which == BOOST_IOS::in) )
      .     .    .       .     .    .       .    .    .       .   .  .   .      {
     30     1    1      12     0    0       6    0    0       0   0  0   0          obj().close(which, next_);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
     12     1    1       8     0    0       0    0    0       0   0  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //----------State changing functions------------------------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
220,087     1    0       0     0    0 125,764   13    0       0   0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::sync_impl()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      std::streamsize avail, amt;
471,615     2    2  94,323     0    0  94,323    0    0  31,441   8  0   0      if ((avail = static_cast<std::streamsize>(pptr() - pbase())) > 0) {
723,005     2    2 188,610     0    0 157,175  492    0  31,435 116  0   0          if ((amt = obj().write(pbase(), avail, next())) == avail)
502,960     2    2  94,305     0    0 157,175    0    0       0   0  0   0              setp(out().begin(), out().end());
      .     .    .       .     .    .       .    .    .       .   .  .   .          else {
      .     .    .       .     .    .       .    .    .       .   .  .   .              const char_type* ptr = pptr();
      .     .    .       .     .    .       .    .    .       .   .  .   .              setp(out().begin() + amt, out().end());
      .     .    .       .     .    .       .    .    .       .   .  .   .              pbump(static_cast<int>(ptr - pptr()));
      .     .    .       .     .    .       .    .    .       .   .  .   .          }
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
220,081     0    0 125,764     0    0       0    0    0       0   0  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .   .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::init_get_area()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      if (shared_buffer() && pptr() != 0) {
      .     .    .       .     .    .       .    .    .       .   .  .   .          sync_impl();
      .     .    .       .     .    .       .    .    .       .   .  .   .          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
      .     .    .       .     .    .       .    .    .       .   .  .   .      setg(in().begin(), in().begin(), in().begin());
      .     .    .       .     .    .       .    .    .       .   .  .   .  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     44     3    1       4     0    0      24    0    0       0   0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::init_put_area()
      .     .    .       .     .    .       .    .    .       .   .  .   .  {
      .     .    .       .     .    .       .    .    .       .   .  .   .      using namespace std;
     32     3    2       4     0    0       4    0    0       8   3  0   0      if (shared_buffer() && gptr() != 0) {
      .     .    .       .     .    .       .    .    .       .   .  .   .          obj().seek(static_cast<off_type>(gptr() - egptr()), BOOST_IOS::cur, BOOST_IOS::in, next_);
      .     .    .       .     .    .       .    .    .       .   .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .   .  .   .      }
     20     5    3       4     0    0       4    0    0       4   1  0   0      if (output_buffered())
     32     1    0       6     0    0      10    0    0       0   0  0   0          setp(out().begin(), out().end());
      .     .    .       .     .    .       .    .    .       .   .  .   .      else
     10     2    2       2     0    0       2    0    0       0   0  0   0          setp(0, 0);
     42     1    1      28     0    0       0    0    0       4   2  0   0  }
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  //----------------------------------------------------------------------------//
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  } } } // End namespaces detail, iostreams, boost.
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  #include <boost/iostreams/detail/config/enable_warnings.hpp> // MSVC, BCC 5.x
      .     .    .       .     .    .       .    .    .       .   .  .   .  
      .     .    .       .     .    .       .    .    .       .   .  .   .  #endif // #ifndef BOOST_IOSTREAMS_DETAIL_INDIRECT_STREAMBUF_HPP_INCLUDED
-- line 447 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc  Bcm Bi Bim 

-- line 89 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         	pointer;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        struct _Vector_impl_data
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	pointer _M_start;
         .    .    .          .    .    .          .    .    .   .   .  .   .  	pointer _M_finish;
         .    .    .          .    .    .          .    .    .   .   .  .   .  	pointer _M_end_of_storage;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
       448   19    1          0    0    0        224    0    0   0   0  0   0  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
       672    6    3        336    0    0        336    5    4   0   0  0   0  	: _M_start(), _M_finish(), _M_end_of_storage()
       336    0    0        224    0    0          0    0    0   0   0  0   0  	{ }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
       505    0    0          0    0    0        303    0    0   0   0  0   0  	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
       404    0    0        404    6    0          0    0    0   0   0  0   0  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
       808   13    1        505    5    0        303   33    0   0   0  0   0  	  _M_end_of_storage(__x._M_end_of_storage)
     1,313    9    0        909    0    0        303    0    0   0   0  0   0  	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  	void
       450    2    1          0    0    0        270    0    0   0   0  0   0  	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{
       360   10    0        270    2    0         90    0    0   0   0  0   0  	  _M_start = __x._M_start;
       360    0    0        270    0    0         90    0    0   0   0  0   0  	  _M_finish = __x._M_finish;
       360    0    0        270    0    0         90    0    0   0   0  0   0  	  _M_end_of_storage = __x._M_end_of_storage;
       270    0    0        180    0    0          0    0    0   0   0  0   0  	}
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  	void
       270   12    1         30    0    0        120    0    0   0   0  0   0  	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  // information used by TBAA.
        90    0    0          0    0    0         30    0    0   0   0  0   0  	  _Vector_impl_data __tmp;
       150    2    1         30    0    0         30    0    0   0   0  0   0  	  __tmp._M_copy_data(*this);
       150    0    0         60    0    0         30    0    0   0   0  0   0  	  _M_copy_data(__x);
       150   12    1         30    0    0         30    0    0   0   0  0   0  	  __x._M_copy_data(__tmp);
       180    2    1        120    0    0          0    0    0  30  12  0   0  	}
         .    .    .          .    .    .          .    .    .   .   .  .   .        };
         .    .    .          .    .    .          .    .    .   .   .  .   .  
     2,277   13    4        621    0    0        621    0    0   0   0  0   0        struct _Vector_impl
         .    .    .          .    .    .          .    .    .   .   .  .   .  	: public _Tp_alloc_type, public _Vector_impl_data
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       105    7    3          0    0    0         42    0    0   0   0  0   0  	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
       126    2    1         42    0    0         42    0    0   0   0  0   0  	: _Tp_alloc_type()
        63    1    0         42    0    0          0    0    0   0   0  0   0  	{ }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
       366   16    3          0    0    0        183    0    0   0   0  0   0  	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
       488    2    1        183    0    0        122    0    0   0   0  0   0  	: _Tp_alloc_type(__a)
       183    0    0        122    0    0          0    0    0   0   0  0   0  	{ }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// Not defaulted, to enforce noexcept(true) even when
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// !is_nothrow_move_constructible<_Tp_alloc_type>.
       707   22    1          0    0    0        404    0    0   0   0  0   0  	_Vector_impl(_Vector_impl&& __x) noexcept
     1,515    5    0        404    0    0        404    0    0   0   0  0   0  	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
       404    0    0        303    0    0          0    0    0   0   0  0   0  	{ }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  	_Vector_impl(_Tp_alloc_type&& __a) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .  	: _Tp_alloc_type(std::move(__a))
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{ }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .  	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{ }
-- line 153 ----------------------------------------
-- line 268 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .  #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
         .    .    .          .    .    .          .    .    .   .   .  .   .        };
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .      public:
         .    .    .          .    .    .          .    .    .   .   .  .   .        typedef _Alloc allocator_type;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Tp_alloc_type&
     1,444   41    8          0    0    0        722    0    0   0   0  0   0        _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
     1,083    0    0      1,083    0    0          0    0    0   0   0  0   0        { return this->_M_impl; }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        const _Tp_alloc_type&
       448    6    2          0    0    0        224    0    0   0   0  0   0        _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
       336    0    0        336    0    0          0    0    0   0   0  0   0        { return this->_M_impl; }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        allocator_type
        90    0    0          0    0    0         45    0    0   0   0  0   0        get_allocator() const _GLIBCXX_NOEXCEPT
       165    2    1         75    0    0         30    0    0   0   0  0   0        { return allocator_type(_M_get_Tp_allocator()); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
       231    4    2         63    0    0         63    0    0   0   0  0   0        _Vector_base() = default;
         .    .    .          .    .    .          .    .    .   .   .  .   .  #else
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_base() { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
       102   13    2          0    0    0         51    0    0   0   0  0   0        _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       136    0    0         68    0    0         17    0    0   0   0  0   0        : _M_impl(__a) { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Kept for ABI compatibility.
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if !_GLIBCXX_INLINE_VERSION
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_base(size_t __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _M_impl()
         .    .    .          .    .    .          .    .    .   .   .  .   .        { _M_create_storage(__n); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
       352    3    1          0    0    0        220    0    0   0   0  0   0        _Vector_base(size_t __n, const allocator_type& __a)
       220   10    2         88    0    0         44    0    0   0   0  0   0        : _M_impl(__a)
       396   16    3        220    3    0         44    0    0   0   0  0   0        { _M_create_storage(__n); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
     1,414    0    0        404    0    0        404    0    0   0   0  0   0        _Vector_base(_Vector_base&&) = default;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Kept for ABI compatibility.
         .    .    .          .    .    .          .    .    .   .   .  .   .  # if !_GLIBCXX_INLINE_VERSION
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_base(_Tp_alloc_type&& __a) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _M_impl(std::move(__a)) { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_base(_Vector_base&& __x, const allocator_type& __a)
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _M_impl(__a)
-- line 316 ----------------------------------------
-- line 325 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  # endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_base(const allocator_type& __a, _Vector_base&& __x)
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .    .    .          .    .    .          .    .    .   .   .  .   .        { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
     1,035   10    4          0    0    0        414    0    0   0   0  0   0        ~_Vector_base() _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
     1,449    0    0        621    0    0        207    0    0   0   0  0   0  	_M_deallocate(_M_impl._M_start,
     1,473    9    3        828    2    0          0    0    0   0   0  0   0  		      _M_impl._M_end_of_storage - _M_impl._M_start);
     1,242    0    0        621    0    0        207    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .      public:
         .    .    .          .    .    .          .    .    .   .   .  .   .        _Vector_impl _M_impl;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        pointer
       498   12    2          0    0    0        249    0    0   0   0  0   0        _M_allocate(size_t __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
       649    0    0        243    0    0         80    0    0  83   5  0   0  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
       166    7    2        166    3    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
     1,708   41    6          0    0    0        976    0    0   0   0  0   0        _M_deallocate(pointer __p, size_t __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
       488    0    0        244    0    0          0    0    0 244  47  0   0  	if (__p)
       600    0    0        300    0    0        100    0    0   0   0  0   0  	  _Tr::deallocate(_M_impl, __p, __n);
       732    0    0        488    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .      protected:
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
       264    3    1          0    0    0        132    0    0   0   0  0   0        _M_create_storage(size_t __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       308   10    1        132    0    0         88    3    0   0   0  0   0  	this->_M_impl._M_start = this->_M_allocate(__n);
       176    2    1        132    0    0         44    0    0   0   0  0   0  	this->_M_impl._M_finish = this->_M_impl._M_start;
       314    3    1        176    0    0         44    0    0   0   0  0   0  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
       132    0    0         88    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .      };
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .    /**
         .    .    .          .    .    .          .    .    .   .   .  .   .     *  @brief A standard container which offers fixed time access to
         .    .    .          .    .    .          .    .    .   .   .  .   .     *  individual elements in any order.
         .    .    .          .    .    .          .    .    .   .   .  .   .     *
         .    .    .          .    .    .          .    .    .   .   .  .   .     *  @ingroup sequences
         .    .    .          .    .    .          .    .    .   .   .  .   .     *
-- line 372 ----------------------------------------
-- line 445 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// Instantiating std::__relocate_a might cause an error outside the
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// immediate context (in __relocate_object_a's noexcept-specifier),
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// so only do it if we know the type can be move-inserted into *this.
         .    .    .          .    .    .          .    .    .   .   .  .   .  	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
         .    .    .          .    .    .          .    .    .   .   .  .   .        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        static pointer
       568    0    0          0    0    0        355    0    0   0   0  0   0        _S_do_relocate(pointer __first, pointer __last, pointer __result,
         .    .    .          .    .    .          .    .    .   .   .  .   .  		     _Tp_alloc_type& __alloc, true_type) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       426   13    1        284    0    0         71    0    0   0   0  0   0  	return std::__relocate_a(__first, __last, __result, __alloc);
       142    0    0        142    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        static pointer
         .    .    .          .    .    .          .    .    .   .   .  .   .        _S_do_relocate(pointer, pointer, pointer __result,
         .    .    .          .    .    .          .    .    .   .   .  .   .  		     _Tp_alloc_type&, false_type) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        { return __result; }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        static pointer
       568    0    0          0    0    0        355    0    0   0   0  0   0        _S_relocate(pointer __first, pointer __last, pointer __result,
         .    .    .          .    .    .          .    .    .   .   .  .   .  		  _Tp_alloc_type& __alloc) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	using __do_it = __bool_constant<_S_use_relocate()>;
       426    0    0        284    0    0         71    0    0   0   0  0   0  	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
       142    0    0        142    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif // C++11
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .      protected:
         .    .    .          .    .    .          .    .    .   .   .  .   .        using _Base::_M_allocate;
         .    .    .          .    .    .          .    .    .   .   .  .   .        using _Base::_M_deallocate;
         .    .    .          .    .    .          .    .    .   .   .  .   .        using _Base::_M_impl;
         .    .    .          .    .    .          .    .    .   .   .  .   .        using _Base::_M_get_Tp_allocator;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
-- line 478 ----------------------------------------
-- line 479 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .      public:
         .    .    .          .    .    .          .    .    .   .   .  .   .        // [23.2.4.1] construct/copy/destroy
         .    .    .          .    .    .          .    .    .   .   .  .   .        // (assign() and get_allocator() are also listed in this section)
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Creates a %vector with no elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
       231   13    4         63    0    0         63    0    0   0   0  0   0        vector() = default;
         .    .    .          .    .    .          .    .    .   .   .  .   .  #else
         .    .    .          .    .    .          .    .    .   .   .  .   .        vector() { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Creates a %vector with no elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __a  An allocator object.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        explicit
        90   12    1          0    0    0         45    0    0   0   0  0   0        vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       120    2    1         60    0    0         15    0    0   0   0  0   0        : _Base(__a) { }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Creates a %vector with default constructed elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __n  The number of elements to initially create.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __a  An allocator.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This constructor fills the %vector with @a __n default
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  constructed elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        explicit
       184    0    0          0    0    0        115    0    0   0   0  0   0        vector(size_type __n, const allocator_type& __a = allocator_type())
       276   14    1         92    0    0         46    0    0   0   0  0   0        : _Base(_S_check_init_len(__n, __a), __a)
       207   10    1        115    3    0         23    0    0   0   0  0   0        { _M_default_initialize(__n); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Creates a %vector with copies of an exemplar element.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __n  The number of elements to initially create.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __value  An element to copy.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __a  An allocator.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 520 ----------------------------------------
-- line 545 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  All the elements of @a __x are copied, but any unused capacity in
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @a __x  will not be copied
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  (i.e. capacity() == size() in the new %vector).
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  The newly-created %vector uses a copy of the allocator object used
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  by @a __x (unless the allocator traits dictate a different object).
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
       252    6    2         21    0    0        147    0    0   0   0  0   0        vector(const vector& __x)
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _Base(__x.size(),
       441    7    3         63    0    0        105    0    0   0   0  0   0  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
        42    0    0         21    0    0         21    0    0   0   0  0   0  	this->_M_impl._M_finish =
       294    5    2         84    0    0         63    0    0   0   0  0   0  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .    .    .          .    .    .          .    .    .   .   .  .   .  				      this->_M_impl._M_start,
        84    0    0         21    0    0         21    0    0   0   0  0   0  				      _M_get_Tp_allocator());
       210    5    1        147    0    0          0    0    0  21   8  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  %Vector move constructor.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  The newly-created %vector contains the exact contents of the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  moved instance.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  The contents of the moved instance are a valid, but unspecified
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
     1,414   10    0        404    0    0        404    0    0   0   0  0   0        vector(vector&&) noexcept = default;
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /// Copy constructor with alternative allocator
         .    .    .          .    .    .          .    .    .   .   .  .   .        vector(const vector& __x, const allocator_type& __a)
         .    .    .          .    .    .          .    .    .   .   .  .   .        : _Base(__x.size(), __a)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	this->_M_impl._M_finish =
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .    .    .          .    .    .          .    .    .   .   .  .   .  				      this->_M_impl._M_start,
-- line 580 ----------------------------------------
-- line 645 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  constructor N times (where N is distance(first,last)) and do
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  no memory reallocation.  But if only input iterators are
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  used, then this will do at most 2N calls to the copy
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  constructor, and logN memory reallocations.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        template<typename _InputIterator,
         .    .    .          .    .    .          .    .    .   .   .  .   .  	       typename = std::_RequireInputIter<_InputIterator>>
        24    3    1          2    0    0         14    0    0   0   0  0   0  	vector(_InputIterator __first, _InputIterator __last,
         .    .    .          .    .    .          .    .    .   .   .  .   .  	       const allocator_type& __a = allocator_type())
        10    0    0          4    0    0          2    0    0   0   0  0   0  	: _Base(__a)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{
        12    2    1          6    0    0          2    0    0   0   0  0   0  	  _M_range_initialize(__first, __last,
         6    0    0          0    0    0          2    0    0   0   0  0   0  			      std::__iterator_category(__first));
        14    2    1         10    0    0          0    0    0   2   2  0   0  	}
         .    .    .          .    .    .          .    .    .   .   .  .   .  #else
         .    .    .          .    .    .          .    .    .   .   .  .   .        template<typename _InputIterator>
         .    .    .          .    .    .          .    .    .   .   .  .   .  	vector(_InputIterator __first, _InputIterator __last,
         .    .    .          .    .    .          .    .    .   .   .  .   .  	       const allocator_type& __a = allocator_type())
         .    .    .          .    .    .          .    .    .   .   .  .   .  	: _Base(__a)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  // Check whether it's an integral type.  If so, it's not an iterator.
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
-- line 667 ----------------------------------------
-- line 670 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  The dtor only erases the elements, and note that if the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  elements themselves are pointers, the pointed-to memory is
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  not touched in any way.  Managing the pointer is the user's
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  responsibility.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
     1,035   20    6          0    0    0        414    0    0   0   0  0   0        ~vector() _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
     1,449    8    3        828   10    2        207    0    0   0   0  0   0  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       828    1    1        207    0    0        207    0    0   0   0  0   0  		      _M_get_Tp_allocator());
         .    .    .          .    .    .          .    .    .   .   .  .   .  	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
     1,242    0    0        621    0    0        207    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  %Vector assignment operator.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __x  A %vector of identical element and allocator types.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  All the elements of @a __x are copied, but any unused capacity in
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @a __x will not be copied.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
-- line 691 ----------------------------------------
-- line 701 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  The contents of @a __x are moved into this %vector (without copying,
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  if the allocators permit it).
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Afterwards @a __x is a valid, but unspecified %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Whether the allocator is moved depends on the allocator traits.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        vector&
        90    0    0          0    0    0         45    0    0   0   0  0   0        operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
        15    2    1          0    0    0         15    0    0   0   0  0   0  	constexpr bool __move_storage =
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  _Alloc_traits::_S_propagate_on_move_assign()
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  || _Alloc_traits::_S_always_equal();
       120    2    1         30    0    0         30    0    0   0   0  0   0  	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
        15    0    0         15    0    0          0    0    0   0   0  0   0  	return *this;
        30    0    0         30    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  %Vector list assignment operator.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __l  An initializer_list.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This function fills a %vector with copies of the elements in the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  initializer list @a __l.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
-- line 724 ----------------------------------------
-- line 803 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // iterators
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read/write iterator that points to the first
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element in the %vector.  Iteration is done in ordinary
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element order.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        iterator
       296    6    3         37    0    0        111    0    0   0   0  0   0        begin() _GLIBCXX_NOEXCEPT
       407    0    0        222    0    0         37    0    0  37   4  0   0        { return iterator(this->_M_impl._M_start); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read-only (constant) iterator that points to the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  first element in the %vector.  Iteration is done in ordinary
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element order.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_iterator
       208    0    0         26    0    0         78    0    0   0   0  0   0        begin() const _GLIBCXX_NOEXCEPT
       286    0    0        156    0    0         26    0    0  26  10  0   0        { return const_iterator(this->_M_impl._M_start); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read/write iterator that points one past the last
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element in the %vector.  Iteration is done in ordinary
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element order.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        iterator
       392    7    3         49    0    0        147    0    0   0   0  0   0        end() _GLIBCXX_NOEXCEPT
       588    0    0        294    0    0         49    0    0  49  15  0   0        { return iterator(this->_M_impl._M_finish); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read-only (constant) iterator that points one past
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  the last element in the %vector.  Iteration is done in
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  ordinary element order.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_iterator
       192    5    2         24    0    0         72    0    0   0   0  0   0        end() const _GLIBCXX_NOEXCEPT
       288    2    1        144    0    0         24    0    0  24  12  0   0        { return const_iterator(this->_M_impl._M_finish); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read/write reverse iterator that points to the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  last element in the %vector.  Iteration is done in reverse
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element order.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        reverse_iterator
         .    .    .          .    .    .          .    .    .   .   .  .   .        rbegin() _GLIBCXX_NOEXCEPT
-- line 847 ----------------------------------------
-- line 910 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_reverse_iterator
         .    .    .          .    .    .          .    .    .   .   .  .   .        crend() const noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        { return const_reverse_iterator(begin()); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // [23.2.4.2] capacity
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**  Returns the number of elements in the %vector.  */
         .    .    .          .    .    .          .    .    .   .   .  .   .        size_type
     1,936    7    1          0    0    0        968    0    0   0   0  0   0        size() const _GLIBCXX_NOEXCEPT
     4,362    0    0      2,904    3    0          0    0    0   0   0  0   0        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**  Returns the size() of the largest possible %vector.  */
         .    .    .          .    .    .          .    .    .   .   .  .   .        size_type
       380   15    1          0    0    0        152    0    0   0   0  0   0        max_size() const _GLIBCXX_NOEXCEPT
       532    0    0        228    0    0        152    0    0   0   0  0   0        { return _S_max_size(_M_get_Tp_allocator()); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Resizes the %vector to the specified number of elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __new_size  Number of elements the %vector should contain.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This function will %resize the %vector to the specified
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  number of elements.  If the number is smaller than the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  %vector's current size the %vector is truncated, otherwise
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  default constructed elements are appended.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         6    1    0          0    0    0          3    0    0   0   0  0   0        resize(size_type __new_size)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         7    0    0          2    0    0          1    0    0   1   0  0   0  	if (__new_size > size())
        11    1    1          3    0    0          2    0    0   0   0  0   0  	  _M_default_append(__new_size - size());
         .    .    .          .    .    .          .    .    .   .   .  .   .  	else if (__new_size < size())
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
         4    1    1          2    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Resizes the %vector to the specified number of elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __new_size  Number of elements the %vector should contain.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __x  Data with which new elements should be populated.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This function will %resize the %vector to the specified
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  number of elements.  If the number is smaller than the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  %vector's current size the %vector is truncated, otherwise
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  the %vector is extended and new elements are populated with
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  given data.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         8    0    0          0    0    0          5    0    0   0   0  0   0        resize(size_type __new_size, const value_type& __x)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         7    0    0          2    0    0          1    0    0   1   1  0   0  	if (__new_size > size())
        17    1    1          5    0    0          3    0    0   0   0  0   0  	  _M_fill_insert(end(), __new_size - size(), __x);
         .    .    .          .    .    .          .    .    .   .   .  .   .  	else if (__new_size < size())
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
         5    1    1          3    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #else
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Resizes the %vector to the specified number of elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __new_size  Number of elements the %vector should contain.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __x  Data with which new elements should be populated.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This function will %resize the %vector to the specified
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  number of elements.  If the number is smaller than the
-- line 971 ----------------------------------------
-- line 999 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        { return size_type(this->_M_impl._M_end_of_storage
         .    .    .          .    .    .          .    .    .   .   .  .   .  			 - this->_M_impl._M_start); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns true if the %vector is empty.  (Thus begin() would
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  equal end().)
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        _GLIBCXX_NODISCARD bool
        24    2    2          3    0    0          9    0    0   0   0  0   0        empty() const _GLIBCXX_NOEXCEPT
        54    1    1         18    0    0         15    0    0   3   2  0   0        { return begin() == end(); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Attempt to preallocate enough memory for specified number of
         .    .    .          .    .    .          .    .    .   .   .  .   .         *          elements.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param  __n  Number of elements required.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @throw  std::length_error  If @a n exceeds @c max_size().
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This function attempts to reserve enough memory for the
-- line 1016 ----------------------------------------
-- line 1035 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @return  Read/write reference to data.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This operator allows for easy, array-style, data access.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Note that data access with this operator is unchecked and
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  out_of_range lookups are not defined. (For checked lookups
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  see at().)
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        reference
38,641,690    4    2          0    0    0 23,185,014    0    0   0   0  0   0        operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	__glibcxx_requires_subscript(__n);
38,641,690    0    0 23,185,014  366    0          0    0    0   0   0  0   0  	return *(this->_M_impl._M_start + __n);
15,456,676    0    0 15,456,676    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @brief  Subscript access to the data contained in the %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @param __n The index of the element for which data should be
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  accessed.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  @return  Read-only (constant) reference to data.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This operator allows for easy, array-style, data access.
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Note that data access with this operator is unchecked and
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  out_of_range lookups are not defined. (For checked lookups
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  see at().)
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_reference
        60    0    0          0    0    0         36    0    0   0   0  0   0        operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	__glibcxx_requires_subscript(__n);
        60    0    0         36    0    0          0    0    0   0   0  0   0  	return *(this->_M_impl._M_start + __n);
        24    0    0         24    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .      protected:
         .    .    .          .    .    .          .    .    .   .   .  .   .        /// Safety check used only from at().
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_range_check(size_type __n) const
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	if (__n >= this->size())
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
-- line 1073 ----------------------------------------
-- line 1124 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .  	return *begin();
         .    .    .          .    .    .          .    .    .   .   .  .   .        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read-only (constant) reference to the data at the first
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element of the %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_reference
        16    2    2          2    0    0          6    0    0   0   0  0   0        front() const _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	__glibcxx_requires_nonempty();
        14    0    0          2    0    0          6    0    0   0   0  0   0  	return *begin();
        10    1    1          8    0    0          0    0    0   2   2  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read/write reference to the data at the last
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element of the %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        reference
        96    2    1         12    0    0         36    0    0   0   0  0   0        back() _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	__glibcxx_requires_nonempty();
       144    0    0         12    0    0         60    0    0   0   0  0   0  	return *(end() - 1);
        60    2    1         48    0    0          0    0    0  12   5  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        /**
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  Returns a read-only (constant) reference to the data at the
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  last element of the %vector.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        const_reference
         .    .    .          .    .    .          .    .    .   .   .  .   .        back() const _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
-- line 1155 ----------------------------------------
-- line 1179 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .         *
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  This is a typical stack operation.  The function creates an
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  element at the end of the %vector and assigns the given data
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  to it.  Due to the nature of a %vector this operation can be
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  done in constant time if the %vector has preallocated space
         .    .    .          .    .    .          .    .    .   .   .  .   .         *  available.
         .    .    .          .    .    .          .    .    .   .   .  .   .         */
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
       162    1    1          0    0    0         81    0    0   0   0  0   0        push_back(const value_type& __x)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       162    0    0        108    0    0          0    0    0  27   2  0   0  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         .    .    .          .    .    .          .    .    .   .   .  .   .  				     __x);
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    ++this->_M_impl._M_finish;
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  }
         .    .    .          .    .    .          .    .    .   .   .  .   .  	else
       243    2    1         81    0    0         54    0    0   0   0  0   0  	  _M_realloc_insert(end(), __x);
        81    0    0         54    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
        72    2    1          0    0    0         36    0    0   0   0  0   0        push_back(value_type&& __x)
       132    0    0         48    0    0         24    0    0   0   0  0   0        { emplace_back(std::move(__x)); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        template<typename... _Args>
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus > 201402L
         .    .    .          .    .    .          .    .    .   .   .  .   .  	reference
         .    .    .          .    .    .          .    .    .   .   .  .   .  #else
         .    .    .          .    .    .          .    .    .   .   .  .   .  	void
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  	emplace_back(_Args&&... __args);
-- line 1212 ----------------------------------------
-- line 1569 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    clear();
         .    .    .          .    .    .          .    .    .   .   .  .   .  	    __throw_exception_again;
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  }
         .    .    .          .    .    .          .    .    .   .   .  .   .  	}
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by the second initialize_dispatch above
         .    .    .          .    .    .          .    .    .   .   .  .   .        template<typename _ForwardIterator>
         .    .    .          .    .    .          .    .    .   .   .  .   .  	void
        16    2    1          0    0    0         10    0    0   0   0  0   0  	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
         .    .    .          .    .    .          .    .    .   .   .  .   .  			    std::forward_iterator_tag)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	{
        12    2    1          4    0    0          4    0    0   0   0  0   0  	  const size_type __n = std::distance(__first, __last);
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  this->_M_impl._M_start
        28    2    1          8    0    0          8    0    0   0   0  0   0  	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
        14    0    0          8    0    0          2    0    0   0   0  0   0  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
         4    0    0          2    0    0          2    0    0   0   0  0   0  	  this->_M_impl._M_finish =
        12    2    1          8    0    0          2    0    0   0   0  0   0  	    std::__uninitialized_copy_a(__first, __last,
         .    .    .          .    .    .          .    .    .   .   .  .   .  					this->_M_impl._M_start,
         8    0    0          2    0    0          2    0    0   0   0  0   0  					_M_get_Tp_allocator());
         8    0    0          6    0    0          0    0    0   0   0  0   0  	}
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by the first initialize_dispatch above and by the
         .    .    .          .    .    .          .    .    .   .   .  .   .        // vector(n,value,a) constructor.
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_fill_initialize(size_type __n, const value_type& __value)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	this->_M_impl._M_finish =
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
         .    .    .          .    .    .          .    .    .   .   .  .   .  					_M_get_Tp_allocator());
         .    .    .          .    .    .          .    .    .   .   .  .   .        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by the vector(n) constructor.
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
       138    0    0          0    0    0         69    0    0   0   0  0   0        _M_default_initialize(size_type __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
        46    9    1         23    0    0         23    0    0   0   0  0   0  	this->_M_impl._M_finish =
       138    0    0         69    0    0         23    0    0   0   0  0   0  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        92    0    0         23    0    0         23    0    0   0   0  0   0  					   _M_get_Tp_allocator());
        69    0    0         46    0    0          0    0    0   0   0  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Internal assign functions follow.  The *_aux functions do the actual
         .    .    .          .    .    .          .    .    .   .   .  .   .        // assignment work for the range versions.
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by the range assign to implement [23.1.1]/9
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1616 ----------------------------------------
-- line 1748 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Emplacing an rvalue of the correct type can use _M_insert_rval.
         .    .    .          .    .    .          .    .    .   .   .  .   .        iterator
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_emplace_aux(const_iterator __position, value_type&& __v)
         .    .    .          .    .    .          .    .    .   .   .  .   .        { return _M_insert_rval(__position, std::move(__v)); }
         .    .    .          .    .    .          .    .    .   .   .  .   .  #endif
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by _M_fill_insert, _M_insert_aux etc.
         .    .    .          .    .    .          .    .    .   .   .  .   .        size_type
       407    8    2         37    0    0        222    0    0   0   0  0   0        _M_check_len(size_type __n, const char* __s) const
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       518    0    0        111    0    0         74    0    0  37   6  0   0  	if (max_size() - size() < __n)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  __throw_length_error(__N(__s));
         .    .    .          .    .    .          .    .    .   .   .  .   .  
       592    4    1        111    0    0        185    0    0   0   0  0   0  	const size_type __len = size() + (std::max)(size(), __n);
       407    4    1        185    0    0         74    0    0  74   3  0   0  	return (__len < size() || __len > max_size()) ? max_size() : __len;
       222    2    0        185    0    0          0    0    0  37   2  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by constructors to check initial size.
         .    .    .          .    .    .          .    .    .   .   .  .   .        static size_type
       250    2    1         25    0    0        125   21   11   0   0  0   0        _S_check_init_len(size_type __n, const allocator_type& __a)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       375   11    1         50    0    0         75    0    0  25   3  0   0  	if (__n > _S_max_size(_Tp_alloc_type(__a)))
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  __throw_length_error(
         .    .    .          .    .    .          .    .    .   .   .  .   .  	      __N("cannot create std::vector larger than max_size()"));
        25   10    2         25    0    0          0    0    0   0   0  0   0  	return __n;
       150    0    0        125    0    0          0    0    0  25   2  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        static size_type
       808   14    2        101    0    0        303    0    0   0   0  0   0        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
         .    .    .          .    .    .          .    .    .   .   .  .   .  	// (even if std::allocator_traits::max_size says we can).
       202    0    0          0    0    0        101    0    0   0   0  0   0  	const size_t __diffmax
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
       404   14    2        101    0    0        202    0    0   0   0  0   0  	const size_t __allocmax = _Alloc_traits::max_size(__a);
       606    0    0        101    0    0        101    0    0   0   0  0   0  	return (std::min)(__diffmax, __allocmax);
       505    0    0        404    0    0          0    0    0 101  16  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Internal erase functions follow.
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
         .    .    .          .    .    .          .    .    .   .   .  .   .        // _M_assign_aux.
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
-- line 1793 ----------------------------------------
-- line 1807 ----------------------------------------
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_erase(iterator __first, iterator __last);
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .   .   .  .   .      private:
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Constant-time move assignment when source object's memory can be
         .    .    .          .    .    .          .    .    .   .   .  .   .        // moved, either because the source's allocator will move too
         .    .    .          .    .    .          .    .    .   .   .  .   .        // or because the allocators are equal.
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
       150   12    1         15    0    0         75    0    0   0   0  0   0        _M_move_assign(vector&& __x, true_type) noexcept
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
       240   14    2         15    0    0         60    0    0   0   0  0   0  	vector __tmp(get_allocator());
        75    0    0         30    0    0         15    0    0   0   0  0   0  	this->_M_impl._M_swap_data(__x._M_impl);
        75    0    0         15    0    0         15    0    0   0   0  0   0  	__tmp._M_impl._M_swap_data(__x._M_impl);
       150   11    2         30    0    0         45    0    0   0   0  0   0  	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
       105    4    2         75    0    0          0    0    0  15   4  0   0        }
         .    .    .          .    .    .          .    .    .   .   .  .   .  
         .    .    .          .    .    .          .    .    .   .   .  .   .        // Do move assignment when it might not be possible to move source
         .    .    .          .    .    .          .    .    .   .   .  .   .        // object's memory, resulting in a linear-time operation.
         .    .    .          .    .    .          .    .    .   .   .  .   .        void
         .    .    .          .    .    .          .    .    .   .   .  .   .        _M_move_assign(vector&& __x, false_type)
         .    .    .          .    .    .          .    .    .   .   .  .   .        {
         .    .    .          .    .    .          .    .    .   .   .  .   .  	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
         .    .    .          .    .    .          .    .    .   .   .  .   .  	  _M_move_assign(std::move(__x), true_type());
-- line 1829 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/FINAL/BEFORE/Solution/src/../hdr/../hdr/Utility.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr    DLmr   Dw         D1mw DLmw Bc Bcm Bi Bim 

-- line 12 ----------------------------------------
         .    .    .          .       .      .          .    .    .  .   .  .   .      TypeShort
         .    .    .          .       .      .          .    .    .  .   .  .   .  };
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  const std::size_t PAYLOAD_TYPE_SIZE[] = {
         .    .    .          .       .      .          .    .    .  .   .  .   .    sizeof(char),
         .    .    .          .       .      .          .    .    .  .   .  .   .    sizeof(short),
         .    .    .          .       .      .          .    .    .  .   .  .   .  };
         .    .    .          .       .      .          .    .    .  .   .  .   .  
        51    3    3          0       0      0          8    0    0  3   2  0   0  static std::map<std::string, PAYLOAD_TYPE> PayLoadType = {
         1    0    0          0       0      0          1    0    0  0   0  0   0      {"UNSIGNED CHAR", PAYLOAD_TYPE::TypeUChar},
         1    0    0          0       0      0          1    0    0  0   0  0   0      {"SHORT", PAYLOAD_TYPE::TypeShort}
         8    1    1          0       0      0          2    0    0  0   0  0   0  };
         .    .    .          .       .      .          .    .    .  .   .  .   .  
       320    2    1          0       0      0        200    0    0  0   0  0   0  std::string str_toupper(std::string s) {
         .    .    .          .       .      .          .    .    .  .   .  .   .      std::transform(s.begin(), s.end(), s.begin(),
     4,670    2    1      1,230       0      0      1,640    0    0  0   0  0   0                     [](unsigned char c){ return std::toupper(c); });
       200    0    0         80       0      0         40    0    0  0   0  0   0      return s;
       240    0    0        200       0      0          0    0    0  0   0  0   0  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
       168    4    2         14       0      0         84    0    0  0   0  0   0  std::vector<std::string> Split(const std::string& input, const char delimiter){
         .    .    .          .       .      .          .    .    .  .   .  .   .  
        42    0    0         14       0      0         14    0    0  0   0  0   0      std::vector<std::string> result;
       168    1    1         14       0      0         42    0    0  0   0  0   0      std::stringstream ss(input);
        84    0    0          0       0      0         28    0    0  0   0  0   0      std::string s;
       574    2    1        123       0      0         82    0    0 41   3  0   0      while (std::getline(ss, s, delimiter)) {
       135    0    0          0       0      0         27    0    0 27   2  0   0          if (s.empty())
         .    .    .          .       .      .          .    .    .  .   .  .   .              continue;
       297    2    1          0       0      0         81    0    0  0   0  0   0          boost::algorithm::trim(s);
       162    1    1         27       0      0         27    0    0  0   0  0   0          result.push_back(s);
         .    .    .          .       .      .          .    .    .  .   .  .   .      }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
        28    0    0          0       0      0          0    0    0  0   0  0   0      return result;
        98    2    2         84       0      0          0    0    0 14   0  0   0  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  std::size_t NearestPowerOfTwo(std::size_t v){
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .      v--;
         .    .    .          .       .      .          .    .    .  .   .  .   .      v |= v >> 1;
         .    .    .          .       .      .          .    .    .  .   .  .   .      v |= v >> 2;
         .    .    .          .       .      .          .    .    .  .   .  .   .      v |= v >> 4;
         .    .    .          .       .      .          .    .    .  .   .  .   .      v |= v >> 8;
         .    .    .          .       .      .          .    .    .  .   .  .   .      v |= v >> 16;
-- line 52 ----------------------------------------
-- line 141 ----------------------------------------
         .    .    .          .       .      .          .    .    .  .   .  .   .      }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  private:
         .    .    .          .       .      .          .    .    .  .   .  .   .      std::size_t m_Size = 0;
         .    .    .          .       .      .          .    .    .  .   .  .   .      T* m_Data;
         .    .    .          .       .      .          .    .    .  .   .  .   .  };
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  template <typename RandomIt>
        70    7    2          7       0      0         35    3    3  0   0  0   0  int parallel_multiply(RandomIt beg, RandomIt end)
         .    .    .          .       .      .          .    .    .  .   .  .   .  {
        28    0    0         14       0      0          7    0    0  0   0  0   0      auto len = end - beg;
        14    0    0          7       0      0          0    0    0  7   3  0   0      if (len < 8)
        32    2    0          8       0      0          4    0    0  0   0  0   0          return std::accumulate(beg, end, 1, std::multiplies<std::size_t>());
         .    .    .          .       .      .          .    .    .  .   .  .   .  
        27    1    1          6       0      0          3    0    0  0   0  0   0      RandomIt mid = beg + len/2;
        36    5    1          0       0      0          6    0    0  0   0  0   0      auto handle = std::async(std::launch::async,
         .    .    .          .       .      .          .    .    .  .   .  .   .                               parallel_multiply<RandomIt>, mid, end);
        18    0    0          6       0      0          6    1    0  0   0  0   0      int product = parallel_multiply(beg, mid);
        15    2    0          3       0      0          3    0    0  0   0  0   0      return product + handle.get();
        49    5    1         35       0      0          0    0    0  7   2  0   0  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  // ref: http://teem.sourceforge.net/nrrd/format.html#encoding
         .    .    .          .       .      .          .    .    .  .   .  .   .  template<typename T>
         .    .    .          .       .      .          .    .    .  .   .  .   .  constexpr bool isValidNrrdEncodedType(){
         .    .    .          .       .      .          .    .    .  .   .  .   .      return std::is_integral_v<T> ||
         .    .    .          .       .      .          .    .    .  .   .  .   .             std::is_floating_point_v<T>;
         .    .    .          .       .      .          .    .    .  .   .  .   .  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
-- line 168 ----------------------------------------
-- line 169 ----------------------------------------
         .    .    .          .       .      .          .    .    .  .   .  .   .  template<typename T, typename = std::enable_if_t<isValidNrrdEncodedType<T>()>>
         .    .    .          .       .      .          .    .    .  .   .  .   .  T DecodeBytesSpcialized(const std::string_view& data, const std::size_t index){
         .    .    .          .       .      .          .    .    .  .   .  .   .      T value;
         .    .    .          .       .      .          .    .    .  .   .  .   .      std::memcpy(&value, (data.data() + index), sizeof(T));
         .    .    .          .       .      .          .    .    .  .   .  .   .      return value;
         .    .    .          .       .      .          .    .    .  .   .  .   .  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  template <>
46,317,450    1    1          0       0      0 23,158,725    0    0  0   0  0   0  std::uint8_t DecodeBytesSpcialized<std::uint8_t>(const std::string_view& data, std::size_t index){
         .    .    .          .       .      .          .    .    .  .   .  .   .      // static cast is faster
46,317,450    4    1 23,158,725 120,987 18,787  7,719,575    0    0  0   0  0   0      return static_cast<std::uint8_t>(data[index]);
15,439,150    0    0 15,439,150      16      0          0    0    0  0   0  0   0  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  template <typename T>
54,037,025    0    0          0       0      0 30,878,300    0    0  0   0  0   0  constexpr inline const T& Clamp(const T& min, const T& val, const T& max){
77,195,750    2    1 23,158,725      19      0 15,439,150   82    0  0   0  0   0      return std::max(min, std::min(max, val));
15,439,150    0    0 15,439,150      37      0          0    0    0  0   0  0   0  }
         .    .    .          .       .      .          .    .    .  .   .  .   .  
         .    .    .          .       .      .          .    .    .  .   .  .   .  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/boost/iostreams/filter/symmetric.hpp
--------------------------------------------------------------------------------
Ir      I1mr ILmr Dr      D1mr DLmr Dw      D1mw DLmw Bc     Bcm   Bi Bim 

-- line 65 ----------------------------------------
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  namespace boost { namespace iostreams {
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  template< typename SymmetricFilter,
      .    .    .       .    .    .       .    .    .      .     .  .   .            typename Alloc =
      .    .    .       .    .    .       .    .    .      .     .  .   .                std::allocator<
      .    .    .       .    .    .       .    .    .      .     .  .   .                    BOOST_DEDUCED_TYPENAME char_type_of<SymmetricFilter>::type
      .    .    .       .    .    .       .    .    .      .     .  .   .                > >
     86    1    1      24    0    0      24    0    0      0     0  0   0  class symmetric_filter {
      .    .    .       .    .    .       .    .    .      .     .  .   .  public:
      .    .    .       .    .    .       .    .    .      .     .  .   .      typedef typename char_type_of<SymmetricFilter>::type      char_type;
      .    .    .       .    .    .       .    .    .      .     .  .   .      typedef BOOST_IOSTREAMS_CHAR_TRAITS(char_type)            traits_type;
      .    .    .       .    .    .       .    .    .      .     .  .   .      typedef std::basic_string<char_type, traits_type, Alloc>  string_type;
      .    .    .       .    .    .       .    .    .      .     .  .   .      struct category
      .    .    .       .    .    .       .    .    .      .     .  .   .          : dual_use,
      .    .    .       .    .    .       .    .    .      .     .  .   .            filter_tag,
      .    .    .       .    .    .       .    .    .      .     .  .   .            multichar_tag,
-- line 81 ----------------------------------------
-- line 133 ----------------------------------------
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .              // Fill buffer.
      .    .    .       .    .    .       .    .    .      .     .  .   .              if (status == f_good)
      .    .    .       .    .    .       .    .    .      .     .  .   .                  status = fill(src);
      .    .    .       .    .    .       .    .    .      .     .  .   .          }
      .    .    .       .    .    .       .    .    .      .     .  .   .      }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Sink>
384,150    3    2  29,550    0    0 236,400    0    0      0     0  0   0      std::streamsize write(Sink& snk, const char_type* s, std::streamsize n)
      .    .    .       .    .    .       .    .    .      .     .  .   .      {
265,950    9    1  59,100    0    0  29,550    0    0 29,550     2  0   0          if (!(state() & f_write))
      3    0    0       1    0    0       1    0    0      0     0  0   0              begin_write();
      .    .    .       .    .    .       .    .    .      .     .  .   .  
147,750    0    0  29,550    0    0  59,100    0    0      0     0  0   0          buffer_type&     buf = pimpl_->buf_;
      .    .    .       .    .    .       .    .    .      .     .  .   .          const char_type *next_s, *end_s;
360,183    1    1 210,572    0    0  59,100    0    0 60,961 1,922  0   0          for (next_s = s, end_s = s + n; next_s != end_s; ) {
423,428    1    1 129,416    0    0  64,708    0    0 64,708    45  0   0              if (buf.ptr() == buf.eptr() && !flush(snk))
      .    .    .       .    .    .       .    .    .      .     .  .   .                  break;
691,064    1    1 157,060   13    0 125,648    0    0 31,412   484  0   0              if(!filter().filter(next_s, end_s, buf.ptr(), buf.eptr(), false)) {
      5    0    0       2    0    0       1    0    0      0     0  0   0                  flush(snk);
      1    0    0       0    0    0       0    0    0      0     0  0   0                  break;
      .    .    .       .    .    .       .    .    .      .     .  .   .              }
      .    .    .       .    .    .       .    .    .      .     .  .   .          }
 59,100    1    1  59,100    0    0       0    0    0      0     0  0   0          return static_cast<std::streamsize>(next_s - s);
236,400    0    0 177,300   14    0       0    0    0 29,550     5  0   0      }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Sink>
     12    1    1       1    0    0       7    0    0      0     0  0   0      void close(Sink& snk, BOOST_IOS::openmode mode)
      .    .    .       .    .    .       .    .    .      .     .  .   .      {
      2    0    0       1    0    0       0    0    0      1     0  0   0          if (mode == BOOST_IOS::out) {
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      9    1    1       2    0    0       1    0    0      1     0  0   0              if (!(state() & f_write))
      .    .    .       .    .    .       .    .    .      .     .  .   .                  begin_write();
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .              // Repeatedly invoke filter() with no input.
      .    .    .       .    .    .       .    .    .      .     .  .   .              try {
      5    0    0       1    0    0       2    0    0      0     0  0   0                  buffer_type&     buf = pimpl_->buf_;
      .    .    .       .    .    .       .    .    .      .     .  .   .                  char_type        dummy;
      2    0    0       0    0    0       1    0    0      0     0  0   0                  const char_type* end = &dummy;
      1    1    1       0    0    0       1    0    0      0     0  0   0                  bool             again = true;
      5    0    0       2    0    0       0    0    0      2     0  0   0                  while (again) {
     12    0    0       4    0    0       2    0    0      1     0  0   0                      if (buf.ptr() != buf.eptr())
     17    1    1       4    0    0       4    0    0      0     0  0   0                          again = filter().filter( end, end, buf.ptr(),
      3    0    0       1    0    0       1    0    0      0     0  0   0                                                   buf.eptr(), true );
      5    1    1       2    0    0       1    0    0      0     0  0   0                      flush(snk);
      .    .    .       .    .    .       .    .    .      .     .  .   .                  }
      .    .    .       .    .    .       .    .    .      .     .  .   .              } catch (...) {
      .    .    .       .    .    .       .    .    .      .     .  .   .                  try { close_impl(); } catch (...) { }
      .    .    .       .    .    .       .    .    .      .     .  .   .                  throw;
      .    .    .       .    .    .       .    .    .      .     .  .   .              }
      3    0    0       1    0    0       1    0    0      0     0  0   0              close_impl();
      .    .    .       .    .    .       .    .    .      .     .  .   .          } else {
      .    .    .       .    .    .       .    .    .      .     .  .   .              close_impl();
      .    .    .       .    .    .       .    .    .      .     .  .   .          }
      9    2    2       6    0    0       0    0    0      1     1  0   0      }
609,650    1    1 182,895    0    0 182,895    0    0      0     0  0   0      SymmetricFilter& filter() { return *pimpl_; }
      .    .    .       .    .    .       .    .    .      .     .  .   .      string_type unconsumed_input() const;
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  // Give impl access to buffer_type on Tru64
      .    .    .       .    .    .       .    .    .      .     .  .   .  #if !BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590042)) 
      .    .    .       .    .    .       .    .    .      .     .  .   .      private:
      .    .    .       .    .    .       .    .    .      .     .  .   .  #endif
      .    .    .       .    .    .       .    .    .      .     .  .   .      typedef detail::buffer<char_type, Alloc> buffer_type;
      .    .    .       .    .    .       .    .    .      .     .  .   .  private:
103,763   93    2  28,299    0    0  28,299    0    0      0     0  0   0      buffer_type& buf() { return pimpl_->buf_; }
      .    .    .       .    .    .       .    .    .      .     .  .   .      const buffer_type& buf() const { return pimpl_->buf_; }
325,094    2    2  88,662    0    0  88,662    0    0      0     0  0   0      int& state() { return pimpl_->state_; }
      .    .    .       .    .    .       .    .    .      .     .  .   .      void begin_read();
      .    .    .       .    .    .       .    .    .      .     .  .   .      void begin_write();
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Source>
      .    .    .       .    .    .       .    .    .      .     .  .   .      int fill(Source& src)
      .    .    .       .    .    .       .    .    .      .     .  .   .      {
      .    .    .       .    .    .       .    .    .      .     .  .   .          std::streamsize amt = iostreams::read(src, buf().data(), buf().size());
      .    .    .       .    .    .       .    .    .      .     .  .   .          if (amt == -1) {
-- line 207 ----------------------------------------
-- line 210 ----------------------------------------
      .    .    .       .    .    .       .    .    .      .     .  .   .          }
      .    .    .       .    .    .       .    .    .      .     .  .   .          buf().set(0, amt);
      .    .    .       .    .    .       .    .    .      .     .  .   .          return amt != 0 ? f_good : f_would_block;
      .    .    .       .    .    .       .    .    .      .     .  .   .      }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      // Attempts to write the contents of the buffer the given Sink.
      .    .    .       .    .    .       .    .    .      .     .  .   .      // Returns true if at least on character was written.
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Sink>
 16,974    1    1   1,886    0    0   7,544    0    0      0     0  0   0      bool flush(Sink& snk)
      .    .    .       .    .    .       .    .    .      .     .  .   .      {
      .    .    .       .    .    .       .    .    .      .     .  .   .          typedef typename iostreams::category_of<Sink>::type  category;
      .    .    .       .    .    .       .    .    .      .     .  .   .          typedef is_convertible<category, output>             can_write;
 15,088    1    1   3,772    0    0   3,772    0    0      0     0  0   0          return flush(snk, can_write());
  9,430    0    0   7,544    0    0       0    0    0  1,886     3  0   0      }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Sink>
 15,088    1    1       0    0    0   9,430    0    0      0     0  0   0      bool flush(Sink& snk, mpl::true_)
      .    .    .       .    .    .       .    .    .      .     .  .   .      {
  5,658    0    0       0    0    0   1,886    0    0      0     0  0   0          std::streamsize amt =
 22,632    2    2   5,658    0    0   7,544    0    0      0     0  0   0              static_cast<std::streamsize>(buf().ptr() - buf().data());
      .    .    .       .    .    .       .    .    .      .     .  .   .          std::streamsize result =
 22,632    9    2   5,658    0    0   7,544    0    0      0     0  0   0              boost::iostreams::write(snk, buf().data(), amt);
  5,658    0    0   3,772    0    0       0    0    0  1,886     3  0   0          if (result < amt && result > 0)
      .    .    .       .    .    .       .    .    .      .     .  .   .              traits_type::move(buf().data(), buf().data() + result, amt - result);
 28,290   15    3   7,544    0    0   7,544    0    0      0     0  0   0          buf().set(amt - result, buf().size());
  3,772    0    0   1,886    0    0       0    0    0      0     0  0   0          return result != 0;
  9,430    1    1   7,544    9    0       0    0    0      0     0  0   0      }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      template<typename Sink>
      .    .    .       .    .    .       .    .    .      .     .  .   .      bool flush(Sink&, mpl::false_) { return true;}
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      void close_impl();
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      enum flag_type {
      .    .    .       .    .    .       .    .    .      .     .  .   .          f_read   = 1,
      .    .    .       .    .    .       .    .    .      .     .  .   .          f_write  = f_read << 1,
      .    .    .       .    .    .       .    .    .      .     .  .   .          f_eof    = f_write << 1,
      .    .    .       .    .    .       .    .    .      .     .  .   .          f_good,
      .    .    .       .    .    .       .    .    .      .     .  .   .          f_would_block
      .    .    .       .    .    .       .    .    .      .     .  .   .      };
      .    .    .       .    .    .       .    .    .      .     .  .   .  
     15    1    1       4    0    0       4    0    0      0     0  0   0      struct impl : SymmetricFilter {
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .      // Expands to a sequence of ctors which forward to SymmetricFilter.
      .    .    .       .    .    .       .    .    .      .     .  .   .      #define BOOST_PP_LOCAL_MACRO(n) \
      .    .    .       .    .    .       .    .    .      .     .  .   .          BOOST_IOSTREAMS_TEMPLATE_PARAMS(n, T) \
      .    .    .       .    .    .       .    .    .      .     .  .   .          impl( std::streamsize buffer_size BOOST_PP_COMMA_IF(n) \
      .    .    .       .    .    .       .    .    .      .     .  .   .                BOOST_PP_ENUM_BINARY_PARAMS(n, const T, &t) ) \
      .    .    .       .    .    .       .    .    .      .     .  .   .              : SymmetricFilter(BOOST_PP_ENUM_PARAMS(n, t)), \
      .    .    .       .    .    .       .    .    .      .     .  .   .                buf_(buffer_size), state_(0) \
-- line 259 ----------------------------------------
-- line 277 ----------------------------------------
      .    .    .       .    .    .       .    .    .      .     .  .   .  void symmetric_filter<SymmetricFilter, Alloc>::begin_read()
      .    .    .       .    .    .       .    .    .      .     .  .   .  {
      .    .    .       .    .    .       .    .    .      .     .  .   .      BOOST_ASSERT(!(state() & f_write));
      .    .    .       .    .    .       .    .    .      .     .  .   .      state() |= f_read;
      .    .    .       .    .    .       .    .    .      .     .  .   .      buf().set(0, 0);
      .    .    .       .    .    .       .    .    .      .     .  .   .  }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  template<typename SymmetricFilter, typename Alloc>
      6    0    0       0    0    0       3    0    0      0     0  0   0  void symmetric_filter<SymmetricFilter, Alloc>::begin_write()
      .    .    .       .    .    .       .    .    .      .     .  .   .  {
      7    0    0       2    0    0       1    0    0      1     1  0   0      BOOST_ASSERT(!(state() & f_read));
      6    1    1       2    0    0       2    0    0      0     0  0   0      state() |= f_write;
     13    0    0       2    0    0       4    0    0      0     0  0   0      buf().set(0, buf().size());
      4    0    0       3    0    0       0    0    0      0     0  0   0  }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  template<typename SymmetricFilter, typename Alloc>
      5    1    1       0    0    0       2    0    0      0     0  0   0  void symmetric_filter<SymmetricFilter, Alloc>::close_impl()
      .    .    .       .    .    .       .    .    .      .     .  .   .  {
      4    0    0       1    0    0       2    0    0      0     0  0   0      state() = 0;
      7    1    1       1    0    0       2    0    0      0     0  0   0      buf().set(0, 0);
      5    0    0       1    0    0       2    0    0      0     0  0   0      filter().close();
      3    0    0       2    0    0       0    0    0      0     0  0   0  }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  template<typename SymmetricFilter, typename Alloc>
      .    .    .       .    .    .       .    .    .      .     .  .   .  typename symmetric_filter<SymmetricFilter, Alloc>::string_type
      .    .    .       .    .    .       .    .    .      .     .  .   .  symmetric_filter<SymmetricFilter, Alloc>::unconsumed_input() const
      .    .    .       .    .    .       .    .    .      .     .  .   .  { return string_type(buf().ptr(), buf().eptr()); }
      .    .    .       .    .    .       .    .    .      .     .  .   .  
      .    .    .       .    .    .       .    .    .      .     .  .   .  //----------------------------------------------------------------------------//
      .    .    .       .    .    .       .    .    .      .     .  .   .  
-- line 306 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/string_view
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc Bcm Bi Bim 

-- line 125 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        __attribute__((__nonnull__)) constexpr
         .    .    .          .    .    .          .    .    .  .   .  .   .        basic_string_view(const _CharT* __str) noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        : _M_len{traits_type::length(__str)},
         .    .    .          .    .    .          .    .    .  .   .  .   .  	_M_str{__str}
         .    .    .          .    .    .          .    .    .  .   .  .   .        { }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr
        72   12    1          0    0    0         48    0    0  0   0  0   0        basic_string_view(const _CharT* __str, size_type __len) noexcept
        72    0    0         48    0    0         24    0    0  0   0  0   0        : _M_len{__len}, _M_str{__str}
        36    0    0         24    0    0          0    0    0  0   0  0   0        { }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .  #if __cplusplus > 201703L && __cpp_lib_concepts
         .    .    .          .    .    .          .    .    .  .   .  .   .        template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
         .    .    .          .    .    .          .    .    .  .   .  .   .  	requires same_as<iter_value_t<_It>, _CharT>
         .    .    .          .    .    .          .    .    .  .   .  .   .  	  && (!convertible_to<_End, size_type>)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	constexpr
         .    .    .          .    .    .          .    .    .  .   .  .   .  	basic_string_view(_It __first, _End __last)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	: _M_len(__last - __first), _M_str(std::to_address(__first))
-- line 143 ----------------------------------------
-- line 179 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reverse_iterator
         .    .    .          .    .    .          .    .    .  .   .  .   .        crend() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return const_reverse_iterator(this->begin()); }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        // [string.view.capacity], capacity
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
30,878,348    5    2          0    0    0 15,439,174    0    0  0   0  0   0        size() const noexcept
30,878,348    0    0 30,878,348  208    0          0    0    0  0   0  0   0        { return this->_M_len; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
         .    .    .          .    .    .          .    .    .  .   .  .   .        length() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return _M_len; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
         .    .    .          .    .    .          .    .    .  .   .  .   .        max_size() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
-- line 196 ----------------------------------------
-- line 200 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        [[nodiscard]] constexpr bool
         .    .    .          .    .    .          .    .    .  .   .  .   .        empty() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return this->_M_len == 0; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        // [string.view.access], element access
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reference
38,597,875   14    2          0    0    0 23,158,725    0    0  0   0  0   0        operator[](size_type __pos) const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
         .    .    .          .    .    .          .    .    .  .   .  .   .  	__glibcxx_assert(__pos < this->_M_len);
30,878,300    0    0 23,158,725   26    0          0    0    0  0   0  0   0  	return *(this->_M_str + __pos);
15,439,150    0    0 15,439,150    0    0          0    0    0  0   0  0   0        }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reference
         .    .    .          .    .    .          .    .    .  .   .  .   .        at(size_type __pos) const
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
         .    .    .          .    .    .          .    .    .  .   .  .   .  	if (__pos >= _M_len)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	  __throw_out_of_range_fmt(__N("basic_string_view::at: __pos "
         .    .    .          .    .    .          .    .    .  .   .  .   .  				       "(which is %zu) >= this->size() "
         .    .    .          .    .    .          .    .    .  .   .  .   .  				       "(which is %zu)"), __pos, this->size());
-- line 220 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr          D1mr    DLmr   Dw          D1mw  DLmw Bc         Bcm    Bi Bim 
--------------------------------------------------------------------------------
1,368,271,619 5,717  408 489,427,421 129,263 18,822 288,371,461 1,424  332 39,174,005 71,395  7   7  events annotated

