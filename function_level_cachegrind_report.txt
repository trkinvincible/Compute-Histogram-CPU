--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./Ex-2 ---i ../res/uchar-gzip.nrrd ---b 256 ---max 256
Data file:        cachegrind.out.15478
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr   ILmr  Dr          D1mr    DLmr   Dw          D1mw    DLmw    Bc         Bcm       Bi      Bim     
--------------------------------------------------------------------------------
1,704,340,672 35,930 8,136 601,665,440 749,345 57,126 343,447,894 455,988 315,832 86,327,370 3,481,660 790,239 119,334  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir          I1mr  ILmr Dr          D1mr    DLmr   Dw         D1mw    DLmw    Bc         Bcm       Bi      Bim     file:function
--------------------------------------------------------------------------------
370,540,068    15    5 138,952,518     545      2 54,037,133      17      12 15,439,174        29       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/histogram.h:ComputeHistogram::Operate()::{lambda()
216,148,100     7    3  54,037,025       1      1 38,597,875      10       0  7,719,575        19       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/histogram.h:ComputeHistogram::DecodeBytes(std::basic_string_view<char, std::char_traits<char> > const&, unsigned long)
192,749,250 5,166  928  47,088,808 246,533    210  9,180,300  23,470     155 27,224,496 2,793,520 664,995 72,803  ???:???
146,671,925     6    2  38,597,875       6      0 46,317,450       8       0          0         0       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/../hdr/Utility.h:double const& RkUtil::Clamp<double>(double const&, double const&, double const&)
115,793,625     8    1  54,037,025       2      0 23,158,725       0       0  7,719,575         5       0      0  /usr/include/c++/10/bits/stl_algobase.h:double const& std::min<double>(double const&, double const&)
114,127,299     4    1  54,037,025      21      0 23,158,725       0       0  7,719,575    66,506       0      0  /usr/include/c++/10/bits/stl_algobase.h:double const& std::max<double>(double const&, double const&)
108,216,850    14    1  38,648,875      24      0 30,919,100       0       0          0         0       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/../hdr/Utility.h:RkUtil::ScopedBin<unsigned int>::operator[](unsigned long)
108,074,050     5    1  38,597,875 120,650 15,393 30,878,300       0       0          0         0       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/../hdr/Utility.h:unsigned char RkUtil::DecodeBytesSpcialized<unsigned char, void>(std::basic_string_view<char, std::char_traits<char> > const&, unsigned long)
 92,757,300    16    1  38,648,875      23      0 23,189,325       3       0          0         0       0      0  /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/../hdr/Utility.h:RkUtil::AlignedContinuousMemory<unsigned int>::operator[](unsigned long)
 84,915,325     7    2  38,597,875       0      0 23,158,725       0       0          0         0       0      0  /usr/include/c++/10/string_view:std::basic_string_view<char, std::char_traits<char> >::operator[](unsigned long) const
 61,756,696     2    1  30,878,348       8      0 15,439,174       0       0          0         0       0      0  /usr/include/c++/10/string_view:std::basic_string_view<char, std::char_traits<char> >::size() const
 43,091,861   932   85   8,812,878  21,292      3  4,938,688   6,481      13  5,871,418   534,367  79,020 40,880  ???:inflate
 11,914,570    37   13   9,361,518 318,647 27,516  9,282,526 350,893 252,046  8,861,760    38,628       0      0  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  3,782,369     0    0           1       1      0  3,782,362  59,099  59,099  3,782,363         7       0      0  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
  2,689,039     8    8     502,350      56      0    650,097      42       0    265,948     1,384       1      1  /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp:boost::iostreams::detail::indirect_streambuf<boost::iostreams::basic_gzip_decompressor<std::allocator<char> >, std::char_traits<char>, std::allocator<char>, boost::iostreams::output>::overflow(int)
  2,568,034     7    7     851,651      10      0    574,508       0       0    216,181    12,934       0      0  /usr/include/boost/iostreams/filter/symmetric.hpp:long boost::iostreams::symmetric_filter<boost::iostreams::detail::zlib_decompressor_impl<std::allocator<char> >, std::allocator<char> >::write<boost::iostreams::detail::linked_streambuf<char, std::char_traits<char> > >(boost::iostreams::detail::linked_streambuf<char, std::char_traits<char> >&, char const*, long)
  2,009,456 2,036    4     472,814      78      0    502,364       0       0     59,102         5       0      0  /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp:boost::iostreams::detail::indirect_streambuf<boost::iostreams::basic_gzip_decompressor<std::allocator<char> >, std::char_traits<char>, std::allocator<char>, boost::iostreams::output>::sync_impl()

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/boost/iostreams/filter/symmetric.hpp
--------------------------------------------------------------------------------
Ir      I1mr  ILmr Dr      D1mr DLmr Dw      D1mw DLmw Bc     Bcm    Bi Bim 

-- line 65 ----------------------------------------
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  namespace boost { namespace iostreams {
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  template< typename SymmetricFilter,
      .     .    .       .    .    .       .    .    .      .      .  .   .            typename Alloc =
      .     .    .       .    .    .       .    .    .      .      .  .   .                std::allocator<
      .     .    .       .    .    .       .    .    .      .      .  .   .                    BOOST_DEDUCED_TYPENAME char_type_of<SymmetricFilter>::type
      .     .    .       .    .    .       .    .    .      .      .  .   .                > >
     86     0    0      24    0    0      24    0    0      0      0  0   0  class symmetric_filter {
      .     .    .       .    .    .       .    .    .      .      .  .   .  public:
      .     .    .       .    .    .       .    .    .      .      .  .   .      typedef typename char_type_of<SymmetricFilter>::type      char_type;
      .     .    .       .    .    .       .    .    .      .      .  .   .      typedef BOOST_IOSTREAMS_CHAR_TRAITS(char_type)            traits_type;
      .     .    .       .    .    .       .    .    .      .      .  .   .      typedef std::basic_string<char_type, traits_type, Alloc>  string_type;
      .     .    .       .    .    .       .    .    .      .      .  .   .      struct category
      .     .    .       .    .    .       .    .    .      .      .  .   .          : dual_use,
      .     .    .       .    .    .       .    .    .      .      .  .   .            filter_tag,
      .     .    .       .    .    .       .    .    .      .      .  .   .            multichar_tag,
-- line 81 ----------------------------------------
-- line 133 ----------------------------------------
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .              // Fill buffer.
      .     .    .       .    .    .       .    .    .      .      .  .   .              if (status == f_good)
      .     .    .       .    .    .       .    .    .      .      .  .   .                  status = fill(src);
      .     .    .       .    .    .       .    .    .      .      .  .   .          }
      .     .    .       .    .    .       .    .    .      .      .  .   .      }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Sink>
384,150     2    2  29,550    0    0 236,400    0    0      0      0  0   0      std::streamsize write(Sink& snk, const char_type* s, std::streamsize n)
      .     .    .       .    .    .       .    .    .      .      .  .   .      {
265,950     1    1  59,100    0    0  29,550    0    0 29,550      2  0   0          if (!(state() & f_write))
      3     0    0       1    0    0       1    0    0      0      0  0   0              begin_write();
      .     .    .       .    .    .       .    .    .      .      .  .   .  
147,750     0    0  29,550    0    0  59,100    0    0      0      0  0   0          buffer_type&     buf = pimpl_->buf_;
      .     .    .       .    .    .       .    .    .      .      .  .   .          const char_type *next_s, *end_s;
360,183     1    1 210,572    0    0  59,100    0    0 60,961  1,920  0   0          for (next_s = s, end_s = s + n; next_s != end_s; ) {
423,428     1    1 129,416    0    0  64,708    0    0 64,708     30  0   0              if (buf.ptr() == buf.eptr() && !flush(snk))
      .     .    .       .    .    .       .    .    .      .      .  .   .                  break;
691,064     1    1 157,060   10    0 125,648    0    0 31,412 10,975  0   0              if(!filter().filter(next_s, end_s, buf.ptr(), buf.eptr(), false)) {
      5     0    0       2    0    0       1    0    0      0      0  0   0                  flush(snk);
      1     0    0       0    0    0       0    0    0      0      0  0   0                  break;
      .     .    .       .    .    .       .    .    .      .      .  .   .              }
      .     .    .       .    .    .       .    .    .      .      .  .   .          }
 59,100     1    1  59,100    0    0       0    0    0      0      0  0   0          return static_cast<std::streamsize>(next_s - s);
236,400     0    0 177,300    0    0       0    0    0 29,550      7  0   0      }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Sink>
     12     2    2       1    0    0       7    0    0      0      0  0   0      void close(Sink& snk, BOOST_IOS::openmode mode)
      .     .    .       .    .    .       .    .    .      .      .  .   .      {
      2     0    0       1    0    0       0    0    0      1      1  0   0          if (mode == BOOST_IOS::out) {
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      9     0    0       2    0    0       1    0    0      1      1  0   0              if (!(state() & f_write))
      .     .    .       .    .    .       .    .    .      .      .  .   .                  begin_write();
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .              // Repeatedly invoke filter() with no input.
      .     .    .       .    .    .       .    .    .      .      .  .   .              try {
      5     1    1       1    0    0       2    0    0      0      0  0   0                  buffer_type&     buf = pimpl_->buf_;
      .     .    .       .    .    .       .    .    .      .      .  .   .                  char_type        dummy;
      2     0    0       0    0    0       1    0    0      0      0  0   0                  const char_type* end = &dummy;
      1     0    0       0    0    0       1    0    0      0      0  0   0                  bool             again = true;
      5     0    0       2    0    0       0    0    0      2      1  0   0                  while (again) {
     12     1    1       4    0    0       2    0    0      1      0  0   0                      if (buf.ptr() != buf.eptr())
     17     1    1       4    0    0       4    0    0      0      0  0   0                          again = filter().filter( end, end, buf.ptr(),
      3     0    0       1    0    0       1    0    0      0      0  0   0                                                   buf.eptr(), true );
      5     0    0       2    0    0       1    0    0      0      0  0   0                      flush(snk);
      .     .    .       .    .    .       .    .    .      .      .  .   .                  }
      .     .    .       .    .    .       .    .    .      .      .  .   .              } catch (...) {
      .     .    .       .    .    .       .    .    .      .      .  .   .                  try { close_impl(); } catch (...) { }
      .     .    .       .    .    .       .    .    .      .      .  .   .                  throw;
      .     .    .       .    .    .       .    .    .      .      .  .   .              }
      3     1    1       1    0    0       1    0    0      0      0  0   0              close_impl();
      .     .    .       .    .    .       .    .    .      .      .  .   .          } else {
      .     .    .       .    .    .       .    .    .      .      .  .   .              close_impl();
      .     .    .       .    .    .       .    .    .      .      .  .   .          }
      9     1    1       6    0    0       0    0    0      1      1  0   0      }
609,650     1    1 182,895    0    0 182,895    0    0      0      0  0   0      SymmetricFilter& filter() { return *pimpl_; }
      .     .    .       .    .    .       .    .    .      .      .  .   .      string_type unconsumed_input() const;
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  // Give impl access to buffer_type on Tru64
      .     .    .       .    .    .       .    .    .      .      .  .   .  #if !BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590042)) 
      .     .    .       .    .    .       .    .    .      .      .  .   .      private:
      .     .    .       .    .    .       .    .    .      .      .  .   .  #endif
      .     .    .       .    .    .       .    .    .      .      .  .   .      typedef detail::buffer<char_type, Alloc> buffer_type;
      .     .    .       .    .    .       .    .    .      .      .  .   .  private:
103,763     1    1  28,299    0    0  28,299    0    0      0      0  0   0      buffer_type& buf() { return pimpl_->buf_; }
      .     .    .       .    .    .       .    .    .      .      .  .   .      const buffer_type& buf() const { return pimpl_->buf_; }
325,094 2,024    1  88,662    0    0  88,662    0    0      0      0  0   0      int& state() { return pimpl_->state_; }
      .     .    .       .    .    .       .    .    .      .      .  .   .      void begin_read();
      .     .    .       .    .    .       .    .    .      .      .  .   .      void begin_write();
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Source>
      .     .    .       .    .    .       .    .    .      .      .  .   .      int fill(Source& src)
      .     .    .       .    .    .       .    .    .      .      .  .   .      {
      .     .    .       .    .    .       .    .    .      .      .  .   .          std::streamsize amt = iostreams::read(src, buf().data(), buf().size());
      .     .    .       .    .    .       .    .    .      .      .  .   .          if (amt == -1) {
-- line 207 ----------------------------------------
-- line 210 ----------------------------------------
      .     .    .       .    .    .       .    .    .      .      .  .   .          }
      .     .    .       .    .    .       .    .    .      .      .  .   .          buf().set(0, amt);
      .     .    .       .    .    .       .    .    .      .      .  .   .          return amt != 0 ? f_good : f_would_block;
      .     .    .       .    .    .       .    .    .      .      .  .   .      }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      // Attempts to write the contents of the buffer the given Sink.
      .     .    .       .    .    .       .    .    .      .      .  .   .      // Returns true if at least on character was written.
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Sink>
 16,974     3    3   1,886    0    0   7,544    0    0      0      0  0   0      bool flush(Sink& snk)
      .     .    .       .    .    .       .    .    .      .      .  .   .      {
      .     .    .       .    .    .       .    .    .      .      .  .   .          typedef typename iostreams::category_of<Sink>::type  category;
      .     .    .       .    .    .       .    .    .      .      .  .   .          typedef is_convertible<category, output>             can_write;
 15,088     0    0   3,772    0    0   3,772    0    0      0      0  0   0          return flush(snk, can_write());
  9,430     1    1   7,544   10    0       0    0    0  1,886      1  0   0      }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Sink>
 15,088     2    2       0    0    0   9,430    0    0      0      0  0   0      bool flush(Sink& snk, mpl::true_)
      .     .    .       .    .    .       .    .    .      .      .  .   .      {
  5,658     1    1       0    0    0   1,886    0    0      0      0  0   0          std::streamsize amt =
 22,632     1    1   5,658    0    0   7,544    0    0      0      0  0   0              static_cast<std::streamsize>(buf().ptr() - buf().data());
      .     .    .       .    .    .       .    .    .      .      .  .   .          std::streamsize result =
 22,632     0    0   5,658    0    0   7,544    9    0      0      0  0   0              boost::iostreams::write(snk, buf().data(), amt);
  5,658     1    1   3,772    0    0       0    0    0  1,886      3  0   0          if (result < amt && result > 0)
      .     .    .       .    .    .       .    .    .      .      .  .   .              traits_type::move(buf().data(), buf().data() + result, amt - result);
 28,290     3    3   7,544    0    0   7,544    0    0      0      0  0   0          buf().set(amt - result, buf().size());
  3,772     0    0   1,886    0    0       0    0    0      0      0  0   0          return result != 0;
  9,430     0    0   7,544    0    0       0    0    0      0      0  0   0      }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      template<typename Sink>
      .     .    .       .    .    .       .    .    .      .      .  .   .      bool flush(Sink&, mpl::false_) { return true;}
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      void close_impl();
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      enum flag_type {
      .     .    .       .    .    .       .    .    .      .      .  .   .          f_read   = 1,
      .     .    .       .    .    .       .    .    .      .      .  .   .          f_write  = f_read << 1,
      .     .    .       .    .    .       .    .    .      .      .  .   .          f_eof    = f_write << 1,
      .     .    .       .    .    .       .    .    .      .      .  .   .          f_good,
      .     .    .       .    .    .       .    .    .      .      .  .   .          f_would_block
      .     .    .       .    .    .       .    .    .      .      .  .   .      };
      .     .    .       .    .    .       .    .    .      .      .  .   .  
     15     0    0       4    0    0       4    0    0      0      0  0   0      struct impl : SymmetricFilter {
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .      // Expands to a sequence of ctors which forward to SymmetricFilter.
      .     .    .       .    .    .       .    .    .      .      .  .   .      #define BOOST_PP_LOCAL_MACRO(n) \
      .     .    .       .    .    .       .    .    .      .      .  .   .          BOOST_IOSTREAMS_TEMPLATE_PARAMS(n, T) \
      .     .    .       .    .    .       .    .    .      .      .  .   .          impl( std::streamsize buffer_size BOOST_PP_COMMA_IF(n) \
      .     .    .       .    .    .       .    .    .      .      .  .   .                BOOST_PP_ENUM_BINARY_PARAMS(n, const T, &t) ) \
      .     .    .       .    .    .       .    .    .      .      .  .   .              : SymmetricFilter(BOOST_PP_ENUM_PARAMS(n, t)), \
      .     .    .       .    .    .       .    .    .      .      .  .   .                buf_(buffer_size), state_(0) \
-- line 259 ----------------------------------------
-- line 277 ----------------------------------------
      .     .    .       .    .    .       .    .    .      .      .  .   .  void symmetric_filter<SymmetricFilter, Alloc>::begin_read()
      .     .    .       .    .    .       .    .    .      .      .  .   .  {
      .     .    .       .    .    .       .    .    .      .      .  .   .      BOOST_ASSERT(!(state() & f_write));
      .     .    .       .    .    .       .    .    .      .      .  .   .      state() |= f_read;
      .     .    .       .    .    .       .    .    .      .      .  .   .      buf().set(0, 0);
      .     .    .       .    .    .       .    .    .      .      .  .   .  }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  template<typename SymmetricFilter, typename Alloc>
      6     1    1       0    0    0       3    0    0      0      0  0   0  void symmetric_filter<SymmetricFilter, Alloc>::begin_write()
      .     .    .       .    .    .       .    .    .      .      .  .   .  {
      7     0    0       2    0    0       1    0    0      1      1  0   0      BOOST_ASSERT(!(state() & f_read));
      6     1    1       2    0    0       2    0    0      0      0  0   0      state() |= f_write;
     13     0    0       2    0    0       4    0    0      0      0  0   0      buf().set(0, buf().size());
      4     0    0       3    0    0       0    0    0      0      0  0   0  }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  template<typename SymmetricFilter, typename Alloc>
      5     1    1       0    0    0       2    0    0      0      0  0   0  void symmetric_filter<SymmetricFilter, Alloc>::close_impl()
      .     .    .       .    .    .       .    .    .      .      .  .   .  {
      4     0    0       1    0    0       2    0    0      0      0  0   0      state() = 0;
      7     0    0       1    0    0       2    0    0      0      0  0   0      buf().set(0, 0);
      5     1    1       1    0    0       2    0    0      0      0  0   0      filter().close();
      3     0    0       2    0    0       0    0    0      0      0  0   0  }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  template<typename SymmetricFilter, typename Alloc>
      .     .    .       .    .    .       .    .    .      .      .  .   .  typename symmetric_filter<SymmetricFilter, Alloc>::string_type
      .     .    .       .    .    .       .    .    .      .      .  .   .  symmetric_filter<SymmetricFilter, Alloc>::unconsumed_input() const
      .     .    .       .    .    .       .    .    .      .      .  .   .  { return string_type(buf().ptr(), buf().eptr()); }
      .     .    .       .    .    .       .    .    .      .      .  .   .  
      .     .    .       .    .    .       .    .    .      .      .  .   .  //----------------------------------------------------------------------------//
      .     .    .       .    .    .       .    .    .      .      .  .   .  
-- line 306 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc        Bcm    Bi Bim 

-- line 222 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .     *
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  This is the simple classic generic implementation.  It will work on
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  temporary expressions, since they are only evaluated once, unlike a
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  preprocessor macro.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX14_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline const _Tp&
38,598,285   16    3          0    0    0 23,158,971    0    0         0      0  0   0      min(const _Tp& __a, const _Tp& __b)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .        //return __b < __a ? __b : __a;
46,317,942    0    0 30,878,628    2    0          0    0    0 7,719,657     22  0   0        if (__b < __a)
15,439,150    0    0  7,719,575    0    0          0    0    0         0      0  0   0  	return __b;
        82    8    2         82    0    0          0    0    0         0      0  0   0        return __a;
15,439,314    0    0 15,439,314    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief This does what you think it does.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup sorting_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __a  A thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __b  Another thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The greater of the parameters.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  This is the simple classic generic implementation.  It will work on
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  temporary expressions, since they are only evaluated once, unlike a
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  preprocessor macro.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX14_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline const _Tp&
38,598,135   17    3          0    0    0 23,158,881    0    0         0      0  0   0      max(const _Tp& __a, const _Tp& __b)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .        //return  __a < __b ? __b : __a;
46,317,762   10    2 30,878,508   32    1          0    0    0 7,719,627 66,532  0   0        if (__a < __b)
12,106,562    0    0  6,053,281    0    0          0    0    0         0      0  0   0  	return __b;
 1,666,346    0    0  1,666,346    0    0          0    0    0         0      0  0   0        return __a;
15,439,254    0    0 15,439,254    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief This does what you think it does.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup sorting_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __a  A thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __b  Another thing of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __comp  A @link comparison_functors comparison functor@endlink.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The lesser of the parameters.
-- line 270 ----------------------------------------
-- line 305 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        return __a;
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Fallback implementation of the function in bits/stl_iterator.h used to
         .    .    .          .    .    .          .    .    .         .      .  .   .    // remove the __normal_iterator wrapper. See copy, fill, ...
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Iterator>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _Iterator
       864   10    2          0    0    0        432    0    0         0      0  0   0      __niter_base(_Iterator __it)
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
       648    1    1        648    0    0          0    0    0         0      0  0   0      { return __it; }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Reverse the __niter_base transformation to get a
         .    .    .          .    .    .          .    .    .         .      .  .   .    // __normal_iterator back again (this assumes that __normal_iterator
         .    .    .          .    .    .          .    .    .         .      .  .   .    // is only used to wrap random access iterators, like pointers).
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _From, typename _To>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _From
         .    .    .          .    .    .          .    .    .         .      .  .   .      __niter_wrap(_From __from, _To __res)
-- line 323 ----------------------------------------
-- line 860 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        for (; __first != __last; ++__first)
         .    .    .          .    .    .          .    .    .         .      .  .   .  	*__first = __value;
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _ForwardIterator, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline typename
         .    .    .          .    .    .          .    .    .         .      .  .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
         6    1    0          0    0    0          4    0    0         0      0  0   0      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _Tp& __value)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         3    0    0          2    0    0          1    0    0         0      0  0   0        const _Tp __tmp = __value;
     1,503    0    0        902    0    0          0    0    0       301      2  0   0        for (; __first != __last; ++__first)
       900    1    1        600    0    0        300   17    0         0      0  0   0  	*__first = __tmp;
         3    0    0          2    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Specialization: for char types we can use memset.
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline typename
         .    .    .          .    .    .          .    .    .         .      .  .   .      __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
-- line 882 ----------------------------------------
-- line 905 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .      void
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	      const _VTp&);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _FIte, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline void
         7    2    1          0    0    0          4    0    0         0      0  0   0      __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
         9    0    0          5    0    0          1    0    0         0      0  0   0      { std::__fill_a1(__first, __last, __value); }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      void
         .    .    .          .    .    .          .    .    .         .      .  .   .      __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	     const _Tp&);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
-- line 922 ----------------------------------------
-- line 947 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .    // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR int
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(int __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(unsigned __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned long
         7    1    1          3    0    0          2    0    0         0      0  0   0    __size_to_integer(unsigned long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR long long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(long long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR unsigned long long
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(unsigned long long __n) { return __n; }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .  #if defined(__GLIBCXX_TYPE_INT_N_0)
         .    .    .          .    .    .          .    .    .         .      .  .   .    inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
         .    .    .          .    .    .          .    .    .         .      .  .   .    __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
-- line 963 ----------------------------------------
-- line 1046 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
         .    .    .          .    .    .          .    .    .         .      .  .   .  #endif
         .    .    .          .    .    .          .    .    .         .      .  .   .        return __fill_n_a1(__first, __n, __value);
         .    .    .          .    .    .          .    .    .         .      .  .   .      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _OutputIterator, typename _Size, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _OutputIterator
         7    0    0          0    0    0          4    0    0         0      0  0   0      __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
         .    .    .          .    .    .          .    .    .         .      .  .   .  	       std::random_access_iterator_tag)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .  #if __cplusplus >= 201103L
         .    .    .          .    .    .          .    .    .         .      .  .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
         .    .    .          .    .    .          .    .    .         .      .  .   .  #endif
         2    0    0          1    0    0          0    0    0         1      1  0   0        if (__n <= 0)
         .    .    .          .    .    .          .    .    .         .      .  .   .  	return __first;
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_requires_can_increment(__first, __n);
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         9    1    1          4    0    0          1    0    0         0      0  0   0        std::__fill_a(__first, __first + __n, __value);
         4    0    0          2    0    0          0    0    0         0      0  0   0        return __first + __n;
         2    0    0          2    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    /**
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @brief Fills the range [first,first+n) with copies of value.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @ingroup mutating_algorithms
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __first  An output iterator.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __n      The count of copies to perform.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @param  __value  A reference-to-const of arbitrary type.
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  @return   The iterator at first+n.
-- line 1075 ----------------------------------------
-- line 1081 ----------------------------------------
         .    .    .          .    .    .          .    .    .         .      .  .   .     *  If @p __n is negative, the function does nothing.
         .    .    .          .    .    .          .    .    .         .      .  .   .    */
         .    .    .          .    .    .          .    .    .         .      .  .   .    // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .    .    .          .    .    .          .    .    .         .      .  .   .    // DR 865. More algorithms that throw away information
         .    .    .          .    .    .          .    .    .         .      .  .   .    // DR 426. search_n(), fill_n(), and generate_n() with negative n
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<typename _OI, typename _Size, typename _Tp>
         .    .    .          .    .    .          .    .    .         .      .  .   .      _GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .      inline _OI
         7    0    0          0    0    0          4    0    0         0      0  0   0      fill_n(_OI __first, _Size __n, const _Tp& __value)
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        // concept requirements
         .    .    .          .    .    .          .    .    .         .      .  .   .        __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         9    0    0          3    0    0          2    0    0         0      0  0   0        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
         3    0    0          0    0    0          1    0    0         0      0  0   0  			       std::__iterator_category(__first));
         2    0    0          2    0    0          0    0    0         0      0  0   0      }
         .    .    .          .    .    .          .    .    .         .      .  .   .  
         .    .    .          .    .    .          .    .    .         .      .  .   .    template<bool _BoolType>
         .    .    .          .    .    .          .    .    .         .      .  .   .      struct __equal
         .    .    .          .    .    .          .    .    .         .      .  .   .      {
         .    .    .          .    .    .          .    .    .         .      .  .   .        template<typename _II1, typename _II2>
         .    .    .          .    .    .          .    .    .         .      .  .   .  	_GLIBCXX20_CONSTEXPR
         .    .    .          .    .    .          .    .    .         .      .  .   .  	static bool
         .    .    .          .    .    .          .    .    .         .      .  .   .  	equal(_II1 __first1, _II1 __last1, _II2 __first2)
-- line 1104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/histogram.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc        Bcm Bi Bim 

-- line 28 ----------------------------------------
          .    .    .          .    .    .          .    .    .         .   .  .   .  #endif
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .  #ifdef RUN_PROFILER
          .    .    .          .    .    .          .    .    .         .   .  .   .  #define PROFILE_STOP ProfilerStop();
          .    .    .          .    .    .          .    .    .         .   .  .   .  #else
          .    .    .          .    .    .          .    .    .         .   .  .   .  #define PROFILE_STOP
          .    .    .          .    .    .          .    .    .         .   .  .   .  #endif
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         44    3    3         12    0    0         12    0    0         0   0  0   0  class ComputeHistogram : public Task{
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .      // Must use some factory method to generate this varaible for type and size based on config
          .    .    .          .    .    .          .    .    .         .   .  .   .      using bins_type = RkUtil::ScopedBin<std::uint32_t>;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .  public:
          8    1    1          0    0    0          5    0    0         0   0  0   0      explicit ComputeHistogram(const std::unique_ptr<RkConfig>& config)
         25    2    2          8    0    0          7    0    0         0   0  0   0          : m_Config(config) {
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          // exit if cannot operate. RAII.
         22    1    1          7    0    0          5    0    0         1   1  0   0          if (m_Config->data().bins < m_Config->data().max){
          .    .    .          .    .    .          .    .    .         .   .  .   .              throw std::runtime_error("bins must be >= max value to represent");
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          9    2    2          4    0    0          3    0    0         0   0  0   0          m_Bins = m_Config->data().bins;
          6    1    1          4    0    0          0    0    0         0   0  0   0      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         10    2    2          1    0    0          5    0    0         0   0  0   0      bool ParseInput() override{
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          8    0    0          2    0    0          3    0    0         0   0  0   0          const std::string& input_file_name = m_Config->data().input_file_name;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          9    1    1          1    0    0          2    0    0         0   0  0   0          std::ifstream input_file_stream(input_file_name, std::ios::in);
          6    0    0          0    0    0          1    0    0         1   1  0   0          if (!input_file_stream.is_open()){
          .    .    .          .    .    .          .    .    .         .   .  .   .              std::cout << __FUNCTION__ << "input_file: " <<
          .    .    .          .    .    .          .    .    .         .   .  .   .                           input_file_name << " not found" << std::endl;
          .    .    .          .    .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
        185   12    2         28    0    0         29    0    0        14   0  0   0          for (std::string line; std::getline(input_file_stream, line); ) {
          .    .    .          .    .    .          .    .    .         .   .  .   .              // strictly NRRD file will have a empty line to seperate header and data. validation must be done on other elemnst as well
         70    0    0          0    0    0         14    0    0        14   1  0   0              if (line.empty())
          7    0    0          0    0    0          1    0    0         1   1  0   0                  break;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         78    1    1          0    0    0         13    0    0         0   0  0   0              std::vector<std::string> vals = RkUtil::Split(line, ':');
         91    0    0          0    0    0         13    0    0        13   4  0   0              if (vals.size() != 2)
          4    0    0          0    0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
        297    2    2          0    0    0         66    0    0        11   4  0   0              if (RkUtil::str_toupper(vals[0]) == "TYPE"){
         27    1    1          2    0    0          7    0    0         0   0  0   0                  m_Type = RkUtil::PayLoadType[RkUtil::str_toupper(vals[1])];
          2    0    0          0    0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .    .    .          .    .    .         .   .  .   .              }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
        270    8    3          0    0    0         60    0    0        10   6  0   0              if (RkUtil::str_toupper(vals[0]) == "DIMENSION"){
          .    .    .          .    .    .          .    .    .         .   .  .   .                  try {
         11    1    0          1    0    0          3    0    0         0   0  0   0                      m_Dimension = std::stoi(vals[1]);
          .    .    .          .    .    .          .    .    .         .   .  .   .                  }catch (...) {
          .    .    .          .    .    .          .    .    .         .   .  .   .                      std::cerr << "Invalid dimensions: " << vals[1] << std::endl;
          .    .    .          .    .    .          .    .    .         .   .  .   .                      m_Dimension = 0;
          .    .    .          .    .    .          .    .    .         .   .  .   .                  };
          2    0    0          0    0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .    .    .          .    .    .         .   .  .   .              }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
        243    6    3          0    0    0         54    0    0         9   2  0   0              if (RkUtil::str_toupper(vals[0]) == "SIZES"){
          .    .    .          .    .    .          .    .    .         .   .  .   .                  // No need const & as copy elision will happen.
         15    2    1          0    0    0          3    0    0         0   0  0   0                  std::vector<std::string> s = RkUtil::Split(vals[1], ' ');
         19    1    1          0    0    0          5    0    0         0   0  0   0                  s.resize(MAX_DIMENSIONS, "1");
        149    3    2         37    0    0         41    0    0         0   0  0   0                  std::generate(m_Sizes.begin(), m_Sizes.end(), [n = 0, s]() mutable{
         16    0    0          0    0    0         16    0    0         0   0  0   0                      std::size_t v = 0;
          .    .    .          .    .    .          .    .    .         .   .  .   .                      try{
        240    1    1         32    0    0         64    0    0         0   0  0   0                          v = std::stoi(s[n++]);
          .    .    .          .    .    .          .    .    .         .   .  .   .                      }catch(...){
          .    .    .          .    .    .          .    .    .         .   .  .   .                          v = 1;
          .    .    .          .    .    .          .    .    .         .   .  .   .                      }
         32    0    0         16    0    0          0    0    0         0   0  0   0                      return v;
         32    1    1         32    0    0          0    0    0         0   0  0   0                  });
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          1    0    0          0    0    0          0    0    0         0   0  0   0                  continue;
          .    .    .          .    .    .          .    .    .         .   .  .   .              }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
        216    5    3          0    0    0         48    0    0         8   2  0   0              if (RkUtil::str_toupper(vals[0]) == "ENCODING"){
         25    2    2          0    0    0          7    0    0         0   0  0   0                  auto itr = RkEncoders::Encoders.find(RkUtil::str_toupper(vals[1]));
         10    0    0          0    0    0          3    0    0         1   0  0   0                  if (itr == RkEncoders::Encoders.end()){
          .    .    .          .    .    .          .    .    .         .   .  .   .                      std::cerr << "Invalid encoding not (yet) supported" << std::endl;
          .    .    .          .    .    .          .    .    .         .   .  .   .                      return false;
          .    .    .          .    .    .          .    .    .         .   .  .   .                  }
         97   16    3          1    0    0         15    0    0        20   7  0   0                  m_Encoder = itr->second;
          .    .    .          .    .    .          .    .    .         .   .  .   .                  continue;
          .    .    .          .    .    .          .    .    .         .   .  .   .              }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          // Since product obtained might be huge lets parallelize.
         15    2    1          3    1    0          4    1    0         0   0  0   0          m_DataSize = RkUtil::parallel_multiply(m_Sizes.begin(), m_Sizes.end());
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          4    1    1          2    0    0          0    0    0         1   0  0   0          if (m_DataSize <= 0){
          .    .    .          .    .    .          .    .    .         .   .  .   .              std::cout << "Empty nrrd data file (not header file) so bail out" << std::endl;
          .    .    .          .    .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         13    2    2          2    0    0          2    0    0         1   0  1   1          if (!m_Encoder->Parse(input_file_stream, input_file_name,
         12    1    1          8    3    1          0    0    0         0   0  0   0                                (m_DataSize * RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]), m_DecompressedData)){
          .    .    .          .    .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          // return true only if input data is fully validated
          1    1    1          0    0    0          0    0    0         0   0  0   0          return true;
          9    1    1          6    1    1          0    0    0         1   0  0   0      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         10    2    2          1    0    0          5    1    1         0   0  0   0      bool Operate() override{
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          try{
          .    .    .          .    .    .          .    .    .         .   .  .   .              /*
          .    .    .          .    .    .          .    .    .         .   .  .   .               * Not good idea to Operate() while Parse() in action because
          .    .    .          .    .    .          .    .    .         .   .  .   .               * # if mid data is corrupted Operate() on previous data goes stale
          .    .    .          .    .    .          .    .    .         .   .  .   .               * Not a good idea to read the file with multiple threads as disk reading HW needle
          .    .    .          .    .    .          .    .    .         .   .  .   .               * is still one which might have to jump sectors and worsen performance.
          .    .    .          .    .    .          .    .    .         .   .  .   .               * or memory map the whole file will exhaust memory if file is too large (can shrink though).
          .    .    .          .    .    .          .    .    .         .   .  .   .              */
         33    2    1          3    0    0         10    1    1         2   2  0   0              for (std::string& slice : m_DecompressedData){
          7    1    1          2    1    1          2    0    0         0   0  0   0                  std::size_t individual_buffer_size = (slice.size() / NO_OF_CORES);
          1    0    0          0    0    0          1    0    0         0   0  0   0                  boost::interprocess::offset_t offset = 0;
          4    0    0          1    0    0          2    0    0         0   0  0   0                  const std::size_t datasize = slice.size();
        125   16    2         62    4    0         13    0    0        13   1  0   0                  for(uint i = 1; i <= NO_OF_CORES; i++, offset += individual_buffer_size){
         48    0    0         24    0    0          0    0    0        12   4  0   0                      if(i == NO_OF_CORES){
          8    1    0          3    0    0          1    0    0         0   0  0   0                          individual_buffer_size = datasize - ((i-1) * individual_buffer_size);
          .    .    .          .    .    .          .    .    .         .   .  .   .                      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         72    2    1         24    0    0         24    0    0         0   0  0   0                      const char* start = (slice.data() + offset);
         72    5    1         24    0    0         12    0    0         0   0  0   0                      std::string_view tmp(start, individual_buffer_size);
         96    0    0         36    4    2         36    0    0         0   0  0   0                      const auto min = m_Config->data().min;
         96    3    1         36    0    0         36    0    0         0   0  0   0                      const auto max = m_Config->data().max;
 30,878,480    8    3 30,878,336   19    0         72   12   12         0   0  0   0                      auto fu = std::async(std::launch::async, [min, max, this, data = std::move(tmp)]() mutable{
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         72    0    0         24    0    0         12    0    0         0   0  0   0                          bins_type hist(m_Bins);
115,793,733    3    1 38,597,899   13    0  7,719,599    3    0 7,719,587  16  0   0                          for (std::size_t idx = 0; idx < data.size(); idx += RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]) {
 61,756,600    2    1 15,439,150    0    0 15,439,150    2    0         0   0  0   0                              auto val = DecodeBytes(data, idx);
          .    .    .          .    .    .          .    .    .         .   .  .   .                              // TODO: caution!!.
          .    .    .          .    .    .          .    .    .         .   .  .   .                              // strictly validate for extents because hist[] is pre allocated based on bins.
          .    .    .          .    .    .          .    .    .         .   .  .   .                              // must implement minmax
 69,476,175    1    0 23,158,725    5    0 15,439,150    0    0         0   0  0   0                              val = RkUtil::Clamp(min, val, max);
 92,634,900    2    1 30,878,300  496    2 15,439,150    0    0 7,719,575   9  0   0                              hist[val] += 1;
          .    .    .          .    .    .          .    .    .         .   .  .   .                          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         48    0    0         12    0    0         12    0    0         0   0  0   0                          hist.canRelease(false);
         12    0    0          0    0    0          0    0    0         0   0  0   0                          return hist;
        300    0    0        132   12    0         84    2    0        12   4  0   0                      });
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         96    5    1         12    0    0         24    0    0         0   0  0   0                      m_Futures.push_back(std::move(fu));
          .    .    .          .    .    .          .    .    .         .   .  .   .                  }
          .    .    .          .    .    .          .    .    .         .   .  .   .              }
          .    .    .          .    .    .          .    .    .         .   .  .   .          }catch(std::exception& ex){
          .    .    .          .    .    .          .    .    .         .   .  .   .              std::cout << "exception occured while computing histogram: why?: " << ex.what() << std::endl;
          .    .    .          .    .    .          .    .    .         .   .  .   .              return false;
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          1    0    0          0    0    0          0    0    0         0   0  0   0          return true;
          9    1    1          6    0    0          0    0    0         1   1  0   0      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          9    2    2          1    0    0          4    0    0         0   0  0   0      void WriteOutput() {
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          /*
          .    .    .          .    .    .          .    .    .         .   .  .   .           * DESIGN NOTE:
          .    .    .          .    .    .          .    .    .         .   .  .   .           * As this exercise is latency sensitive than memory sensitive.
          .    .    .          .    .    .          .    .    .         .   .  .   .           * threads work on independent memory. sharing the same memory and using atomics or mutex will slow down.
          .    .    .          .    .    .          .    .    .         .   .  .   .           * atomics is lock free but not wait free.
          .    .    .          .    .    .          .    .    .         .   .  .   .           * Eg:
          .    .    .          .    .    .          .    .    .         .   .  .   .           *  |   |   |   |
-- line 191 ----------------------------------------
-- line 202 ----------------------------------------
          .    .    .          .    .    .          .    .    .         .   .  .   .           *  * (&&) above mean multithreading.
          .    .    .          .    .    .          .    .    .         .   .  .   .           *
          .    .    .          .    .    .          .    .    .         .   .  .   .           * If GPU available vectorization (tensors) with a ton of threads litreally one (grids/blocks)thread per
          .    .    .          .    .    .          .    .    .         .   .  .   .           * pixel shall be spawned with CUDA/OpenCL/Metal APIs or with SIMD instructions(Single instruction, multiple data )
          .    .    .          .    .    .          .    .    .         .   .  .   .           *
          .    .    .          .    .    .          .    .    .         .   .  .   .           * Maybe I will submit another solution in '*.cu' with only the kernel function later.
          .    .    .          .    .    .          .    .    .         .   .  .   .          */
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          2    0    0          0    0    0          1    0    0         0   0  0   0  PROFILE_START
          7    0    0          0    0    0          2    0    0         0   0  0   0          bins_type ret;
         95   22    1         12    0    0         12    0    0        12   1  0   0          while(!m_Futures.empty()){
         60    0    0         12    0    0         24    0    0         0   0  0   0              auto& fu1 = m_Futures.front();
        156   11    1         12    0    0         36    0    0         0   0  0   0              ret = fu1.get();
         48    0    0         12    4    0         12    0    0         0   0  0   0              m_Futures.pop_front();
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         72   12    1         12    0    0         12    0    0        12   1  0   0              if (m_Futures.empty())
          1    1    0          0    0    0          0    0    0         0   0  0   0                  break;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         66   11    1          0    0    0         22    0    0         0   0  0   0              std::promise<bins_type> merge_promise;
         88    0    0          0    0    0         22    0    0         0   0  0   0              std::future<bins_type> merge_future = merge_promise.get_future();
      1,342   74    4        363    1    0        341    9    0         0   0  0   0              auto mergefu = std::async(std::launch::async, [this, first = std::move(ret), second = std::move(merge_future)]() mutable{
         99    0    0         11    0    0         22    0    0         0   0  0   0                  auto other = second.get();
         66   11    1         22    0    0         11    0    0         0   0  0   0                  bins_type ret(m_Bins);
        154   11    1         11    0    0         44    0    0        11   2  0   0                  assert(first->size() == other->size());
     36,410   10    1      9,922    0    0      6,633    0    0     3,311  11  0   0                  for (std::size_t i = 0; i < ret->size(); ++i){
     66,000   11    1     23,100  378    8     13,200    0    0         0   0  0   0                      ret[i] = first[i] + other[i];
          .    .    .          .    .    .          .    .    .         .   .  .   .                  }
         55    0    0         11    0    0         11    0    0         0   0  0   0                  first.canRelease(true);
         44    0    0          0    0    0         11    0    0         0   0  0   0                  other.canRelease(true);
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         44   10    1         11    0    0         11    0    0         0   0  0   0                  ret.canRelease(false);
         22    0    0          0    0    0          0    0    0         0   0  0   0                  return ret;
        330   28    2         77    0    0         66    0    0        11   0  0   0              });
          .    .    .          .    .    .          .    .    .         .   .  .   .  
         88    0    0         11    0    0         22    0    0         0   0  0   0              m_Futures.push_back(std::move(mergefu));
         55   11    1         11    0    0         22    0    0         0   0  0   0              auto& fu2 = m_Futures.front();
        143   18    1         11    0    0         33    0    0         0   0  0   0              merge_promise.set_value(fu2.get());
         44    0    0         11    4    0         11    0    0         0   0  0   0              m_Futures.pop_front();
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          1    0    0          0    0    0          1    0    0         0   0  0   0  PROFILE_STOP
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          // Copy the output for unit test
         15    1    1          2    0    0          4    0    0         0   0  0   0          std::ofstream output(m_Config->data().output_file_name);
          6    0    0          0    0    0          3    0    0         0   0  0   0          const auto s = ret->size();
          6    1    1          2    0    0          1    0    0         0   0  0   0          m_Output.resize(s);
      1,504    0    0        902    0    0          1    0    0       301   1  0   0          for (std::size_t i = 0; i < s; ++i){
      1,800    1    1        300    0    0        600    0    0         0   0  0   0              const auto& c = ret[i];
      2,700    0    0      1,200   15    0        600    2    0         0   0  0   0              m_Output[i] = c;
      7,200    2    2        900    0    0      1,800    0    0         0   0  0   0              output << "(" << i << ", " << c << ")" << '\n';
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          4    1    1          0    0    0          1    0    0         0   0  0   0          ret.canRelease(true);
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          3    0    0          0    0    0          1    0    0         0   0  0   0          output.close();
          .    .    .          .    .    .          .    .    .         .   .  .   .  #if 0
          .    .    .          .    .    .          .    .    .         .   .  .   .          const std::string tmp = std::string("subl ") + std::string(m_Config->data().output_file_name);
          .    .    .          .    .    .          .    .    .         .   .  .   .          system(tmp.data());
          .    .    .          .    .    .          .    .    .         .   .  .   .  #endif
          7    2    1          5    1    1          0    0    0         1   0  0   0      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .  #ifdef RUN_CATCH
          .    .    .          .    .    .          .    .    .         .   .  .   .      std::size_t OutputVal(){
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          return std::accumulate(m_Output.begin(), m_Output.end(), 0);
          .    .    .          .    .    .          .    .    .         .   .  .   .      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  #endif
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .  private:
          .    .    .          .    .    .          .    .    .         .   .  .   .  
 54,037,025    3    1          0    0    0 30,878,300    0    0         0   0  0   0      double DecodeBytes(const std::string_view& data, std::size_t index){
          .    .    .          .    .    .          .    .    .         .   .  .   .  
 61,756,600    2    1 23,158,725    1    1          0    0    0 7,719,575  19  0   0          switch (RkUtil::PAYLOAD_TYPE_SIZE[(int)m_Type]) {
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          case 1:         //uchar
 69,476,175    0    0 15,439,150    0    0  7,719,575   10    0         0   0  0   0              return RkUtil::DecodeBytesSpcialized<uint8_t>(data, index);
          .    .    .          .    .    .          .    .    .         .   .  .   .              break;
          .    .    .          .    .    .          .    .    .         .   .  .   .          case 2:         // short
          .    .    .          .    .    .          .    .    .         .   .  .   .              return RkUtil::DecodeBytesSpcialized<int16_t>(data, index);
          .    .    .          .    .    .          .    .    .         .   .  .   .              break;
          .    .    .          .    .    .          .    .    .         .   .  .   .          }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .          return 0.0;
 30,878,300    2    1 15,439,150    0    0          0    0    0         0   0  0   0      }
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .      static constexpr int MAX_DIMENSIONS = 16;
          .    .    .          .    .    .          .    .    .         .   .  .   .  
          .    .    .          .    .    .          .    .    .         .   .  .   .      RkUtil::PAYLOAD_TYPE m_Type;
          .    .    .          .    .    .          .    .    .         .   .  .   .      std::uint16_t m_Bins;
          .    .    .          .    .    .          .    .    .         .   .  .   .      std::uint8_t m_Dimension;
          .    .    .          .    .    .          .    .    .         .   .  .   .      std::array<std::size_t, MAX_DIMENSIONS> m_Sizes;
          .    .    .          .    .    .          .    .    .         .   .  .   .      std::shared_ptr<RkEncoders::IEncoder> m_Encoder;
-- line 292 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/boost/iostreams/detail/streambuf/indirect_streambuf.hpp
--------------------------------------------------------------------------------
Ir      I1mr  ILmr Dr      D1mr  DLmr Dw      D1mw DLmw Bc      Bcm   Bi Bim 

-- line 42 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .     .  .   .  #include <boost/iostreams/detail/config/disable_warnings.hpp>  // MSVC, BCC 5.x
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  namespace boost { namespace iostreams { namespace detail {
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //
      .     .    .       .     .    .       .    .    .       .     .  .   .  // Description: The implementation of basic_streambuf used by chains.
      .     .    .       .     .    .       .    .    .       .     .  .   .  //
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     66     6    6      18     0    0      18    0    0       0     0  0   0  class indirect_streambuf
      .     .    .       .     .    .       .    .    .       .     .  .   .      : public linked_streambuf<BOOST_DEDUCED_TYPENAME char_type_of<T>::type, Tr>
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .  public:
      .     .    .       .     .    .       .    .    .       .     .  .   .      typedef typename char_type_of<T>::type                    char_type;
      .     .    .       .     .    .       .    .    .       .     .  .   .      BOOST_IOSTREAMS_STREAMBUF_TYPEDEFS(Tr)
      .     .    .       .     .    .       .    .    .       .     .  .   .  private:
      .     .    .       .     .    .       .    .    .       .     .  .   .      typedef typename category_of<T>::type                     category;
      .     .    .       .     .    .       .    .    .       .     .  .   .      typedef concept_adapter<T>                                wrapper;
-- line 58 ----------------------------------------
-- line 95 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .     .  .   .      void set_next(streambuf_type* next);
      .     .    .       .     .    .       .    .    .       .     .  .   .      void close_impl(BOOST_IOS::openmode m);
      .     .    .       .     .    .       .    .    .       .     .  .   .      const boost::core::typeinfo& component_type() const { return BOOST_CORE_TYPEID(T); }
      .     .    .       .     .    .       .    .    .       .     .  .   .      void* component_impl() { return component(); }
      .     .    .       .     .    .       .    .    .       .     .  .   .  private:
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      //----------Accessor functions--------------------------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
345,906     3    3  94,338     0    0  94,338    1    0       0     0  0   0      wrapper& obj() { return *storage_; }
251,480     3    2 125,740     0    0  62,870    0    0       0     0  0   0      streambuf_type* next() const { return next_; }
      .     .    .       .     .    .       .    .    .       .     .  .   .      buffer_type& in() { return buffer_.first(); }
691,636    96    1 188,628     0    0 188,628    0    0       0     0  0   0      buffer_type& out() { return buffer_.second(); }
     14     2    2       4     0    0       4    0    0       0     0  0   0      bool can_read() const { return is_convertible<Mode, input>::value; }
     28     3    3       8     0    0       8    0    0       0     0  0   0      bool can_write() const { return is_convertible<Mode, output>::value; }
691,614     3    2 251,496 1,703    0 125,748    0    0       0     0  0   0      bool output_buffered() const { return (flags_ & f_output_buffered) != 0; }
220,073     3    2  62,878     0    0  62,878    0    0       0     0  0   0      bool shared_buffer() const { return is_convertible<Mode, seekable>::value || is_convertible<Mode, dual_seekable>::value; }
      .     .    .       .     .    .       .    .    .       .     .  .   .      void set_flags(int f) { flags_ = f; }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      //----------State changing functions--------------------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      virtual void init_get_area();
      .     .    .       .     .    .       .    .    .       .     .  .   .      virtual void init_put_area();
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      //----------Utility function----------------------------------------------//
-- line 118 ----------------------------------------
-- line 138 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .     .  .   .      >                           buffer_;
      .     .    .       .     .    .       .    .    .       .     .  .   .      std::streamsize             pback_size_;
      .     .    .       .     .    .       .    .    .       .     .  .   .      int                         flags_;
      .     .    .       .     .    .       .    .    .       .     .  .   .  };
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //--------------Implementation of indirect_streambuf--------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     18     2    2       0     0    0       9    0    0       0     0  0   0  indirect_streambuf<T, Tr, Alloc, Mode>::indirect_streambuf()
     72     7    7      30     0    0      21    0    0       0     0  0   0      : next_(0), pback_size_(0), flags_(f_auto_close) { }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //--------------Implementation of open, is_open and close---------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     24     2    2       2     0    0      14    1    0       0     0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::open
      .     .    .       .     .    .       .    .    .       .     .  .   .      (const T& t, std::streamsize buffer_size, std::streamsize pback_size)
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      using namespace std;
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      // Normalize buffer sizes.
      2     0    0       0     0    0       2    0    0       0     0  0   0      buffer_size =
      6     1    1       4     0    0       0    0    0       2     2  0   0          (buffer_size != -1) ?
      .     .    .       .     .    .       .    .    .       .     .  .   .          buffer_size :
      .     .    .       .     .    .       .    .    .       .     .  .   .          iostreams::optimal_buffer_size(t);
      2     0    0       0     0    0       2    0    0       0     0  0   0      pback_size =
     10     1    1       4     0    0       0    0    0       2     2  0   0          (pback_size != -1) ?
      2     0    0       0     0    0       0    0    0       0     0  0   0          pback_size :
      .     .    .       .     .    .       .    .    .       .     .  .   .          default_pback_buffer_size;
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      // Construct input buffer.
     10     1    1       2     0    0       2    0    0       2     2  0   0      if (can_read()) {
      .     .    .       .     .    .       .    .    .       .     .  .   .          pback_size_ = (std::max)(std::streamsize(2), pback_size); // STLPort needs 2.
      .     .    .       .     .    .       .    .    .       .     .  .   .          std::streamsize size =
      .     .    .       .     .    .       .    .    .       .     .  .   .              pback_size_ +
      .     .    .       .     .    .       .    .    .       .     .  .   .              ( buffer_size ? buffer_size: std::streamsize(1) );
      .     .    .       .     .    .       .    .    .       .     .  .   .          in().resize(static_cast<int>(size));
      .     .    .       .     .    .       .    .    .       .     .  .   .          if (!shared_buffer())
      .     .    .       .     .    .       .    .    .       .     .  .   .              init_get_area();
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .      // Construct output buffer.
     30     4    4       4     0    0       4    0    0       6     0  0   0      if (can_write() && !shared_buffer()) {
      4     0    0       2     0    0       0    0    0       2     0  0   0          if (buffer_size != std::streamsize(0))
     18     1    1       4     0    0       4    0    0       0     0  0   0              out().resize(static_cast<int>(buffer_size));
     14     1    1       8     2    0       2    0    0       0     0  2   2          init_put_area();
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
     25     2    2       4     0    0       5    0    0       0     0  0   0      storage_.reset(wrapper(t));
     12     1    1       6     0    0       2    0    0       0     0  0   0      flags_ |= f_open;
     22     1    1       4     0    0       2    0    0       6     0  0   0      if (can_write() && buffer_size > 1)
     12     0    0       6     0    0       2    0    0       0     0  0   0          flags_ |= f_output_buffered;
      8     2    2       2     0    0       2    0    0       0     0  0   0      this->set_true_eof(false);
      6     0    0       2     0    0       2    0    0       0     0  0   0      this->set_needs_close();
     14     0    0      10     0    0       0    0    0       2     1  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     20     4    4       0     0    0      10    0    0       0     0  0   0  inline bool indirect_streambuf<T, Tr, Alloc, Mode>::is_open() const
     35     3    3      20     1    0       0    0    0       0     0  0   0  { return (flags_ & f_open) != 0; }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .     .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::close()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      using namespace std;
      .     .    .       .     .    .       .    .    .       .     .  .   .      base_type* self = this;
      .     .    .       .     .    .       .    .    .       .     .  .   .      detail::execute_all(
      .     .    .       .     .    .       .    .    .       .     .  .   .          detail::call_member_close(*self, BOOST_IOS::in),
      .     .    .       .     .    .       .    .    .       .     .  .   .          detail::call_member_close(*self, BOOST_IOS::out),
      .     .    .       .     .    .       .    .    .       .     .  .   .          detail::call_reset(storage_),
      .     .    .       .     .    .       .    .    .       .     .  .   .          detail::clear_flags(flags_)
      .     .    .       .     .    .       .    .    .       .     .  .   .      );
      .     .    .       .     .    .       .    .    .       .     .  .   .  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      8     3    3       0     0    0       4    0    0       0     0  0   0  bool indirect_streambuf<T, Tr, Alloc, Mode>::auto_close() const
     14     1    1       8     0    0       0    0    0       0     0  0   0  { return (flags_ & f_auto_close) != 0; }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     12     1    1       0     0    0       6    0    0       0     0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::set_auto_close(bool close)
     24     1    1      12     0    0       2    0    0       2     1  0   0  { flags_ = (flags_ & ~f_auto_close) | (close ? f_auto_close : 0); }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //--------------Implementation virtual functions------------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  #ifndef BOOST_IOSTREAMS_NO_LOCALE
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .     .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::imbue(const std::locale& loc)
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      if (is_open()) {
-- line 224 ----------------------------------------
-- line 275 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .     .  .   .          return traits_type::not_eof(c);
      .     .    .       .     .    .       .    .    .       .     .  .   .      } else {
      .     .    .       .     .    .       .    .    .       .     .  .   .          boost::throw_exception(bad_putback());
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      .     .    .       .     .    .       .    .    .       .     .  .   .  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .     .  .   .  typename indirect_streambuf<T, Tr, Alloc, Mode>::int_type
314,350     4    4  31,435     0    0 157,175    0    0       0     0  0   0  indirect_streambuf<T, Tr, Alloc, Mode>::overflow(int_type c)
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
471,523     2    2  62,870     0    0  62,870    0    0 125,738    10  0   0      if ( (output_buffered() && pptr() == 0) ||
 94,299     0    0  31,433     0    0  31,433    0    0       0     0  0   0           (shared_buffer() && gptr() != 0) )
      .     .    .       .     .    .       .    .    .       .     .  .   .      {
     14     1    1       8     1    0       2    0    0       0     0  2   2          init_put_area();
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
314,350   156    1       0     0    0  94,305    0    0  31,435     0  0   0      if (!traits_type::eq_int_type(c, traits_type::eof())) {
157,175     0    0  31,435     0    0  31,435    0    0  31,435 1,373  0   0          if (output_buffered()) {
345,785 1,886    2  62,870     0    0  62,870    0    0  31,435     3  0   0              if (pptr() == epptr()) {
 94,299     0    0  31,433     0    0  31,433    0    0       0     0  0   0                  sync_impl();
345,763   143    0  62,866     0    0  62,866    0    0  31,433     7  0   0                  if (pptr() == epptr())
      .     .    .       .     .    .       .    .    .       .     .  .   .                      return traits_type::eof();
      .     .    .       .     .    .       .    .    .       .     .  .   .              }
251,480     2    2  31,435     0    0  94,305   43    1       0     0  0   0              *pptr() = traits_type::to_char_type(c);
157,175     1    1  31,435     0    0  31,435    0    0       0     0  0   0              pbump(1);
      .     .    .       .     .    .       .    .    .       .     .  .   .          } else {
      .     .    .       .     .    .       .    .    .       .     .  .   .              char_type d = traits_type::to_char_type(c);
      .     .    .       .     .    .       .    .    .       .     .  .   .              if (obj().write(&d, 1, next_) != 1)
      .     .    .       .     .    .       .    .    .       .     .  .   .                  return traits_type::eof();
      .     .    .       .     .    .       .    .    .       .     .  .   .          }
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
125,740     4    2       0     0    0  31,435    0    0       0     0  0   0      return traits_type::not_eof(c);
188,610     0    0 157,175    65    0       0    0    0  31,435     8  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     48     3    3       0     0    0      24    0    0       0     0  0   0  int indirect_streambuf<T, Tr, Alloc, Mode>::sync()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      try { // sync() is no-throw.
     24     0    0       8     0    0       8    0    0       0     0  0   0          sync_impl();
     72     1    1      24     0    0      16    0    0       0     0  0   0          obj().flush(next_);
      8     1    1       0     0    0       0    0    0       0     0  0   0          return 0;
      .     .    .       .     .    .       .    .    .       .     .  .   .      } catch (...) { return -1; }
     40     0    0      24     0    0       0    0    0       0     0  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .     .  .   .  bool indirect_streambuf<T, Tr, Alloc, Mode>::strict_sync()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      try { // sync() is no-throw.
      .     .    .       .     .    .       .    .    .       .     .  .   .          sync_impl();
      .     .    .       .     .    .       .    .    .       .     .  .   .          return obj().flush(next_);
      .     .    .       .     .    .       .    .    .       .     .  .   .      } catch (...) { return false; }
-- line 324 ----------------------------------------
-- line 370 ----------------------------------------
      .     .    .       .     .    .       .    .    .       .     .  .   .      else {
      .     .    .       .     .    .       .    .    .       .     .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      .     .    .       .     .    .       .    .    .       .     .  .   .      return obj().seek(off, way, which, next_);
      .     .    .       .     .    .       .    .    .       .     .  .   .  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     10     1    1       0     0    0       6    0    0       0     0  0   0  inline void indirect_streambuf<T, Tr, Alloc, Mode>::set_next
      .     .    .       .     .    .       .    .    .       .     .  .   .      (streambuf_type* next)
     12     0    0       8     0    0       2    0    0       0     0  0   0  { next_ = next; }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     24     1    1       0     0    0      12    0    0       0     0  0   0  inline void indirect_streambuf<T, Tr, Alloc, Mode>::close_impl
      .     .    .       .     .    .       .    .    .       .     .  .   .      (BOOST_IOS::openmode which)
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      if (which == BOOST_IOS::in && is_convertible<Mode, input>::value) {
      .     .    .       .     .    .       .    .    .       .     .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      8     0    0       4     0    0       0    0    0       4     2  0   0      if (which == BOOST_IOS::out && is_convertible<Mode, output>::value) {
     14     0    0       8     0    0       2    0    0       0     0  2   2          sync();
     10     0    0       2     0    0       2    0    0       0     0  0   0          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      4     1    1       2     0    0       0    0    0       2     1  0   0      if ( !is_convertible<category, dual_use>::value ||
      .     .    .       .     .    .       .    .    .       .     .  .   .           is_convertible<Mode, input>::value == (which == BOOST_IOS::in) )
      .     .    .       .     .    .       .    .    .       .     .  .   .      {
     30     1    1      12     0    0       6    0    0       0     0  0   0          obj().close(which, next_);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
     12     1    1       8     0    0       0    0    0       0     0  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //----------State changing functions------------------------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
220,087 2,031    1       0     0    0 125,764    8    0       0     0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::sync_impl()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      std::streamsize avail, amt;
471,615     3    2  94,323     0    0  94,323    0    0  31,441     6  0   0      if ((avail = static_cast<std::streamsize>(pptr() - pbase())) > 0) {
723,005     3    2 188,610     0    0 157,175    0    0  31,435     3  0   0          if ((amt = obj().write(pbase(), avail, next())) == avail)
502,960     2    2  94,305     0    0 157,175    0    0       0     0  0   0              setp(out().begin(), out().end());
      .     .    .       .     .    .       .    .    .       .     .  .   .          else {
      .     .    .       .     .    .       .    .    .       .     .  .   .              const char_type* ptr = pptr();
      .     .    .       .     .    .       .    .    .       .     .  .   .              setp(out().begin() + amt, out().end());
      .     .    .       .     .    .       .    .    .       .     .  .   .              pbump(static_cast<int>(ptr - pptr()));
      .     .    .       .     .    .       .    .    .       .     .  .   .          }
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
220,081     0    0 125,764    87    0       0    0    0       0     0  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
      .     .    .       .     .    .       .    .    .       .     .  .   .  void indirect_streambuf<T, Tr, Alloc, Mode>::init_get_area()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      if (shared_buffer() && pptr() != 0) {
      .     .    .       .     .    .       .    .    .       .     .  .   .          sync_impl();
      .     .    .       .     .    .       .    .    .       .     .  .   .          setp(0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
      .     .    .       .     .    .       .    .    .       .     .  .   .      setg(in().begin(), in().begin(), in().begin());
      .     .    .       .     .    .       .    .    .       .     .  .   .  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  template<typename T, typename Tr, typename Alloc, typename Mode>
     44     1    1       4     0    0      24    0    0       0     0  0   0  void indirect_streambuf<T, Tr, Alloc, Mode>::init_put_area()
      .     .    .       .     .    .       .    .    .       .     .  .   .  {
      .     .    .       .     .    .       .    .    .       .     .  .   .      using namespace std;
     32     1    1       4     0    0       4    0    0       8     7  0   0      if (shared_buffer() && gptr() != 0) {
      .     .    .       .     .    .       .    .    .       .     .  .   .          obj().seek(static_cast<off_type>(gptr() - egptr()), BOOST_IOS::cur, BOOST_IOS::in, next_);
      .     .    .       .     .    .       .    .    .       .     .  .   .          setg(0, 0, 0);
      .     .    .       .     .    .       .    .    .       .     .  .   .      }
     20     4    3       4     0    0       4    0    0       4     1  0   0      if (output_buffered())
     32     1    0       6     0    0      10    0    0       0     0  0   0          setp(out().begin(), out().end());
      .     .    .       .     .    .       .    .    .       .     .  .   .      else
     10     2    2       2     0    0       2    0    0       0     0  0   0          setp(0, 0);
     42     1    1      28     0    0       0    0    0       4     4  0   0  }
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  //----------------------------------------------------------------------------//
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  } } } // End namespaces detail, iostreams, boost.
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  #include <boost/iostreams/detail/config/enable_warnings.hpp> // MSVC, BCC 5.x
      .     .    .       .     .    .       .    .    .       .     .  .   .  
      .     .    .       .     .    .       .    .    .       .     .  .   .  #endif // #ifndef BOOST_IOSTREAMS_DETAIL_INDIRECT_STREAMBUF_HPP_INCLUDED
-- line 447 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/10/string_view
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr DLmr Dw         D1mw DLmw Bc Bcm Bi Bim 

-- line 125 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        __attribute__((__nonnull__)) constexpr
         .    .    .          .    .    .          .    .    .  .   .  .   .        basic_string_view(const _CharT* __str) noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        : _M_len{traits_type::length(__str)},
         .    .    .          .    .    .          .    .    .  .   .  .   .  	_M_str{__str}
         .    .    .          .    .    .          .    .    .  .   .  .   .        { }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr
        72    3    1          0    0    0         48    0    0  0   0  0   0        basic_string_view(const _CharT* __str, size_type __len) noexcept
        72    0    0         48    0    0         24    0    0  0   0  0   0        : _M_len{__len}, _M_str{__str}
        36    0    0         24    0    0          0    0    0  0   0  0   0        { }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .  #if __cplusplus > 201703L && __cpp_lib_concepts
         .    .    .          .    .    .          .    .    .  .   .  .   .        template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
         .    .    .          .    .    .          .    .    .  .   .  .   .  	requires same_as<iter_value_t<_It>, _CharT>
         .    .    .          .    .    .          .    .    .  .   .  .   .  	  && (!convertible_to<_End, size_type>)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	constexpr
         .    .    .          .    .    .          .    .    .  .   .  .   .  	basic_string_view(_It __first, _End __last)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	: _M_len(__last - __first), _M_str(std::to_address(__first))
-- line 143 ----------------------------------------
-- line 179 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reverse_iterator
         .    .    .          .    .    .          .    .    .  .   .  .   .        crend() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return const_reverse_iterator(this->begin()); }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        // [string.view.capacity], capacity
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
30,878,348    2    1          0    0    0 15,439,174    0    0  0   0  0   0        size() const noexcept
30,878,348    0    0 30,878,348    8    0          0    0    0  0   0  0   0        { return this->_M_len; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
         .    .    .          .    .    .          .    .    .  .   .  .   .        length() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return _M_len; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr size_type
         .    .    .          .    .    .          .    .    .  .   .  .   .        max_size() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
-- line 196 ----------------------------------------
-- line 200 ----------------------------------------
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        [[nodiscard]] constexpr bool
         .    .    .          .    .    .          .    .    .  .   .  .   .        empty() const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        { return this->_M_len == 0; }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        // [string.view.access], element access
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reference
38,597,875    7    2          0    0    0 23,158,725    0    0  0   0  0   0        operator[](size_type __pos) const noexcept
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
         .    .    .          .    .    .          .    .    .  .   .  .   .  	__glibcxx_assert(__pos < this->_M_len);
30,878,300    0    0 23,158,725    0    0          0    0    0  0   0  0   0  	return *(this->_M_str + __pos);
15,439,150    0    0 15,439,150    0    0          0    0    0  0   0  0   0        }
         .    .    .          .    .    .          .    .    .  .   .  .   .  
         .    .    .          .    .    .          .    .    .  .   .  .   .        constexpr const_reference
         .    .    .          .    .    .          .    .    .  .   .  .   .        at(size_type __pos) const
         .    .    .          .    .    .          .    .    .  .   .  .   .        {
         .    .    .          .    .    .          .    .    .  .   .  .   .  	if (__pos >= _M_len)
         .    .    .          .    .    .          .    .    .  .   .  .   .  	  __throw_out_of_range_fmt(__N("basic_string_view::at: __pos "
         .    .    .          .    .    .          .    .    .  .   .  .   .  				       "(which is %zu) >= this->size() "
         .    .    .          .    .    .          .    .    .  .   .  .   .  				       "(which is %zu)"), __pos, this->size());
-- line 220 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /media/trk/DATA/Code-Factory/MINE/synopsys/Ex-2/Project/src/../hdr/../hdr/Utility.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr   Dw         D1mw DLmw Bc    Bcm Bi Bim 

-- line 18 ----------------------------------------
          .    .    .          .       .      .          .    .    .     .   .  .   .      TypeShort
          .    .    .          .       .      .          .    .    .     .   .  .   .  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  const std::size_t PAYLOAD_TYPE_SIZE[] = {
          .    .    .          .       .      .          .    .    .     .   .  .   .    sizeof(char),
          .    .    .          .       .      .          .    .    .     .   .  .   .    sizeof(short),
          .    .    .          .       .      .          .    .    .     .   .  .   .  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         48    4    4          0       0      0          6    0    0     3   1  0   0  static std::map<std::string, PAYLOAD_TYPE> PayLoadType = {
          1    0    0          0       0      0          1    0    0     0   0  0   0      {"UNSIGNED CHAR", PAYLOAD_TYPE::TypeUChar},
          1    0    0          0       0      0          1    0    0     0   0  0   0      {"SHORT", PAYLOAD_TYPE::TypeShort}
          8    0    0          0       0      0          2    0    0     0   0  0   0  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        320    1    1          0       0      0        200    0    0     0   0  0   0  std::string str_toupper(std::string s) {
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::transform(s.begin(), s.end(), s.begin(),
      4,670    1    1      1,230       0      0      1,640    0    0     0   0  0   0                     [](unsigned char c){ return std::toupper(c); });
        200    0    0         80       0      0         40    0    0     0   0  0   0      return s;
        240    0    0        200       0      0          0    0    0     0   0  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        168    2    2         14       0      0         84    0    0     0   0  0   0  std::vector<std::string> Split(const std::string& input, const char delimiter){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         42    0    0         14       0      0         14    0    0     0   0  0   0      std::vector<std::string> result;
        168    0    0         14       0      0         42    0    0     0   0  0   0      std::stringstream ss(input);
         84    4    2          0       0      0         28    0    0     0   0  0   0      std::string s;
        574    1    1        123       0      0         82    0    0    41   4  0   0      while (std::getline(ss, s, delimiter)) {
        135    0    0          0       0      0         27    0    0    27   2  0   0          if (s.empty())
          .    .    .          .       .      .          .    .    .     .   .  .   .              continue;
        297    1    1          0       0      0         81    0    0     0   0  0   0          boost::algorithm::trim(s);
        162    0    0         27       0      0         27    0    0     0   0  0   0          result.push_back(s);
          .    .    .          .       .      .          .    .    .     .   .  .   .      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         28    0    0          0       0      0          0    0    0     0   0  0   0      return result;
         98    5    1         84       0      0          0    0    0    14   2  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         52   12    1          0       0      0         26    0    0     0   0  0   0  std::size_t NearestPowerOfTwo(std::size_t v){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         13    0    0         13       0      0          0    0    0     0   0  0   0      v--;
         39    0    0         26       0      0          0    0    0     0   0  0   0      v |= v >> 1;
         39    0    0         26       0      0          0    0    0     0   0  0   0      v |= v >> 2;
         39    4    1         26       0      0          0    0    0     0   0  0   0      v |= v >> 4;
         39    0    0         26       0      0          0    0    0     0   0  0   0      v |= v >> 8;
         39    0    0         26       0      0          0    0    0     0   0  0   0      v |= v >> 16;
         39    0    0         26       0      0          0    0    0     0   0  0   0      v |= v >> 32;
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         13    0    0         13       0      0          0    0    0     0   0  0   0      v++;
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         13    0    0         13       0      0          0    0    0     0   0  0   0      return v;
         26    0    0         26       0      0          0    0    0     0   0  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  // Lock-free is not wait free. with this container no need memory fence.
          .    .    .          .       .      .          .    .    .     .   .  .   .  // will yield better performance in GPU/Metal
          .    .    .          .       .      .          .    .    .     .   .  .   .  template<typename T>
          .    .    .          .       .      .          .    .    .     .   .  .   .  class AlignedContinuousMemory
          .    .    .          .       .      .          .    .    .     .   .  .   .  {
          .    .    .          .       .      .          .    .    .     .   .  .   .      static constexpr std::size_t  CACHELINE_SIZE{64};
          .    .    .          .       .      .          .    .    .     .   .  .   .  
-- line 73 ----------------------------------------
-- line 113 ----------------------------------------
          .    .    .          .       .      .          .    .    .     .   .  .   .              }
          .    .    .          .       .      .          .    .    .     .   .  .   .              std::swap(other.m_Data, this->m_Data);
          .    .    .          .       .      .          .    .    .     .   .  .   .              std::swap(other.m_Size, this->m_Size);
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .          return *this;
          .    .    .          .       .      .          .    .    .     .   .  .   .      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        130    7    1         13       0      0         65    0    0     0   0  0   0      AlignedContinuousMemory(std::size_t size = 0)
          .    .    .          .       .      .          .    .    .     .   .  .   .          : m_Size(size),
         65    0    0         39       0      0         26    0    0     0   0  0   0            m_Data(nullptr)
          .    .    .          .       .      .          .    .    .     .   .  .   .      {
         52    0    0         26       0      0          0    0    0    13   0  0   0          if (m_Size > 0){
          .    .    .          .       .      .          .    .    .     .   .  .   .              try{
         65    5    1         26       0      0         26    0    0     0   0  0   0                  const auto s = NearestPowerOfTwo(m_Size);
        169    4    1         39       0      0         39    0    0     0   0  0   0                  m_Data = static_cast<T*>(std::aligned_alloc(std::max(CACHELINE_SIZE, s), sizeof(T) * size));
         39    0    0         13       0      0         13    0    0     0   0  0   0                  clear();
          .    .    .          .       .      .          .    .    .     .   .  .   .              }catch(std::exception& ex){
          .    .    .          .       .      .          .    .    .     .   .  .   .                  std::cerr << " histo bins memory allocation failed" << std::endl;
          .    .    .          .       .      .          .    .    .     .   .  .   .                  throw;
          .    .    .          .       .      .          .    .    .     .   .  .   .              }
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
         91    0    0         65       0      0          0    0    0    13   1  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .      template<typename ...Args>
          .    .    .          .       .      .          .    .    .     .   .  .   .      void emplace_back(Args&&... args) {
          .    .    .          .       .      .          .    .    .     .   .  .   .          new(&m_Data[m_Size]) T(std::forward<Args>(args)...);
          .    .    .          .       .      .          .    .    .     .   .  .   .          ++m_Size;
          .    .    .          .       .      .          .    .    .     .   .  .   .      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
 38,648,875   13    0          0       0      0 23,189,325    3    0     0   0  0   0      T& operator[](std::size_t pos) {
 38,648,875    3    1 23,189,325      23      0          0    0    0     0   0  0   0          return *reinterpret_cast<T*>(&m_Data[pos]);
 15,459,550    0    0 15,459,550       0      0          0    0    0     0   0  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         65    2    2          0       0      0         26    0    0     0   0  0   0      ~AlignedContinuousMemory() {
     23,465    0    0     15,639       8      0         13    0    0 3,913  15  0   0          for(std::size_t pos = 0; pos < m_Size; ++pos) {
          .    .    .          .       .      .          .    .    .     .   .  .   .              reinterpret_cast<T*>(&m_Data[pos])->~T();
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
         52    0    0         26       0      0          0    0    0    13   2  0   0          if (m_Data){
         52    0    0         26       0      0         13    0    0     0   0  0   0              std::free(m_Data);
         26    1    0         13       0      0         13    0    0     0   0  0   0              m_Data = nullptr;
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
         39    0    0         26       0      0          0    0    0     0   0  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
     13,336    0    0          0       0      0      6,668    0    0     0   0  0   0      std::size_t size() const {
          .    .    .          .       .      .          .    .    .     .   .  .   .  
      6,668    0    0      6,668      15      0          0    0    0     0   0  0   0          return m_Size;
      6,668    0    0      6,668       0      0          0    0    0     0   0  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        115    3    1          0       0      0         46    0    0     0   0  0   0      void clear() {
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         92    0    0         46       4      0          0    0    0    23   0  0   0          if (m_Data){
        184   13    1         92       0      0         23    0    0     0   0  0   0              memset(m_Data, 0, sizeof(T) * m_Size);
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
         69    0    0         46       0      0          0    0    0     0   0  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  private:
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::size_t m_Size = 0;
          .    .    .          .       .      .          .    .    .     .   .  .   .      T* m_Data;
          .    .    .          .       .      .          .    .    .     .   .  .   .  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  template<typename T, std::size_t N>
         23    2    2          6       0      0          6    0    0     0   0  0   0  class BinMemPool : public std::enable_shared_from_this<BinMemPool<T, N>>{
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  public:
        414    0    0         46       0      0        184    0    0     0   0  0   0      std::shared_ptr<BinMemPool<T, N>> getBinMemPool() {
        230   22    1         92       0      0         46    0    0     0   0  0   0          return this->shared_from_this();
        276    0    0        230       0      0          0    0    0    46   4  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          8    2    2          1       0      0          3    0    0     0   0  0   0      ~BinMemPool(){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          6    0    0          1       0      0          1    0    0     1   1  0   0          assert(m_AcquiredBuffers.empty());
        213    2    2          3       0      0         58    0    0    14   2  0   0          for (auto& i : m_AvailableBuffers){
        169    1    1         78       7      0         26    0    0    13   0  0   0              delete i;
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
         17    1    0          7       0      0          3    0    0     1   1  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        230    0    0         23       0      0        115    0    0     0   0  0   0      AlignedContinuousMemory<T>* GetBuffer(){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        207   23    2         23       0      0         46    0    0     0   0  0   0          std::lock_guard<std::mutex> lk(m_Gurad);
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        138    1    0         23       0      0         23    0    0    23  11  0   0          if (m_AvailableBuffers.empty()){
         91    5    1          0       0      0         39    0    0     0   0  0   0              AlignedContinuousMemory<T>* m = new AlignedContinuousMemory<T>(N);
         78    0    0         13       0      0         13    0    0     0   0  0   0              m_AcquiredBuffers.insert(m);
         26    0    0         13       0      0          0    0    0     0   0  0   0              return m;
          .    .    .          .       .      .          .    .    .     .   .  .   .          }else{
         50   10    0         10       0      0         20    0    0     0   0  0   0              auto itr = m_AvailableBuffers.begin();
         50   10    1         10       2      0         20    0    0     0   0  0   0              auto d = *itr;
         60    0    0         10       0      0         10    0    0     0   0  0   0              m_AcquiredBuffers.insert(d);
         60    0    0         20       0      0         10    0    0     0   0  0   0              m_AvailableBuffers.erase(itr);
         30   10    0         10       0      0         10    0    0     0   0  0   0              d->clear();
         10    0    0         10       0      0          0    0    0     0   0  0   0              return d;
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
        207   14    1        138       5      0          0    0    0    23   6  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        230   27    1         23       0      0        115    0    0     0   0  0   0      void ReleaseBuffer(AlignedContinuousMemory<T>* freeBuf){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        207    0    0         23       0      0         46    0    0     0   0  0   0          std::lock_guard<std::mutex> lk(m_Gurad);
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        161   17    1         23       0      0         46    0    0     0   0  0   0          auto itr = m_AcquiredBuffers.find(freeBuf);
        276    0    0         23       0      0         69    0    0    23   2  0   0          assert(itr != m_AcquiredBuffers.end());
        184   11    1         23       0      0         46    0    0     0   0  0   0          m_AvailableBuffers.insert(*itr);
        138   21    1         46       0      0         23    0    0     0   0  0   0          m_AcquiredBuffers.erase(itr);
        161   22    0        115       0      0          0    0    0    23   2  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  private:
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::mutex m_Gurad;
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::unordered_set<AlignedContinuousMemory<T>*> m_AvailableBuffers;
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::unordered_set<AlignedContinuousMemory<T>*> m_AcquiredBuffers;
          .    .    .          .       .      .          .    .    .     .   .  .   .  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  // Class for memory recycling. RAII pattern
          .    .    .          .       .      .          .    .    .     .   .  .   .  template<typename T>
          .    .    .          .       .      .          .    .    .     .   .  .   .  struct ScopedBin{
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  public:
        240   13    1         24       0      0        120   12   12     0   0  0   0      ScopedBin(std::size_t size=0)
         96    0    0         48       0      0         48    0    0     0   0  0   0          : m_Data(nullptr){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         48   14    1         24       0      0          0    0    0    24   2  0   0          if (size > 0){
        391   17    1         23       0      0        138    3    0     0   0  0   0              m_Data = m_MemPool->getBinMemPool()->GetBuffer();
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
        191    6    1        120       3      0          0    0    0    24   3  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
      1,000    3    0        125       0      0        375    0    0     0   0  0   0      ~ScopedBin(){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        592    0    0        296       0      0          0    0    0   148  24  0   0          if (m_Data && m_CanRelease){
        437   14    1         46       0      0        115    0    0     0   0  0   0              m_MemPool->getBinMemPool()->ReleaseBuffer(m_Data);
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
        750    4    0        500       0      0          0    0    0   125   2  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
      1,111    1    1        202       0      0        505   19    0     0   0  0   0      ScopedBin(ScopedBin&& rhs) noexcept{
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        909    0    0        202       0      0        303    0    0     0   0  0   0          this->m_Data = std::exchange(rhs.m_Data, nullptr);
        808    5    1        202       0      0        303    0    0     0   0  0   0          this->m_CanRelease = std::exchange(rhs.m_CanRelease, true);
        606    0    0        404       0      0          0    0    0   101  12  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        120    0    0         12       0      0         60    0    0     0   0  0   0      ScopedBin& operator=(ScopedBin&& rhs){
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         36    0    0         24       0      0          0    0    0    12   1  0   0          if (this != &rhs){
         48   12    1         24       3      0          0    0    0    12   3  0   0              if (m_Data){
          .    .    .          .       .      .          .    .    .     .   .  .   .                  m_MemPool->getBinMemPool()->ReleaseBuffer(m_Data);
          .    .    .          .       .      .          .    .    .     .   .  .   .                  m_Data = nullptr;
          .    .    .          .       .      .          .    .    .     .   .  .   .              }
        108   23    2         24       0      0         36    0    0     0   0  0   0              this->m_Data = std::exchange(rhs.m_Data, nullptr);
         96    0    0         24       0      0         36    0    0     0   0  0   0              this->m_CanRelease = std::exchange(rhs.m_CanRelease, true);
          .    .    .          .       .      .          .    .    .     .   .  .   .          }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         12    0    0         12       0      0          0    0    0     0   0  0   0          return *this;
         72    2    1         60       0      0          0    0    0    12   2  0   0      }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
        552    0    0        184       0      0        184    0    0     0   0  0   0      void canRelease(bool b) { m_CanRelease = b; }
     26,672    1    0     13,336       0      0      6,668    0    0     0   0  0   0      RkUtil::AlignedContinuousMemory<T>* operator->(){ return m_Data; }
108,216,850   14    1 38,648,875      24      0 30,919,100    0    0     0   0  0   0      T& operator[](std::size_t index){ return (*m_Data)[index]; }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  private:
          .    .    .          .       .      .          .    .    .     .   .  .   .      // Always armed to release the memory unless explicity set
          .    .    .          .       .      .          .    .    .     .   .  .   .      bool m_CanRelease = true;
          .    .    .          .       .      .          .    .    .     .   .  .   .      RkUtil::AlignedContinuousMemory<T>* m_Data;
          .    .    .          .       .      .          .    .    .     .   .  .   .      // bin will have multiple singleton instances of mempool of different sizes. MAX_HIST_BIN_SIZE is TODO:
          .    .    .          .       .      .          .    .    .     .   .  .   .      static std::shared_ptr<BinMemPool<T, MAX_HIST_BIN_SIZE>> m_MemPool;
          .    .    .          .       .      .          .    .    .     .   .  .   .  };
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  template <typename T>
         13    1    1          1       1      1          3    0    0     1   0  0   0  std::shared_ptr<BinMemPool<T, MAX_HIST_BIN_SIZE>> ScopedBin<T>::m_MemPool = std::make_shared<BinMemPool<T, MAX_HIST_BIN_SIZE>>();
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  template <typename RandomIt>
         70    4    2          7       0      0         35    3    2     0   0  0   0  int parallel_multiply(RandomIt beg, RandomIt end)
          .    .    .          .       .      .          .    .    .     .   .  .   .  {
         28    0    0         14       0      0          7    0    0     0   0  0   0      auto len = end - beg;
         14    0    0          7       0      0          0    0    0     7   3  0   0      if (len < 8)
         32    0    0          8       0      0          4    0    0     0   0  0   0          return std::accumulate(beg, end, 1, std::multiplies<std::size_t>());
          .    .    .          .       .      .          .    .    .     .   .  .   .  
         27    2    1          6       0      0          3    0    0     0   0  0   0      RandomIt mid = beg + len/2;
         36    1    1          0       0      0          6    0    0     0   0  0   0      auto handle = std::async(std::launch::async,
          .    .    .          .       .      .          .    .    .     .   .  .   .                               parallel_multiply<RandomIt>, mid, end);
         18    0    0          6       0      0          6    0    0     0   0  0   0      int product = parallel_multiply(beg, mid);
         15    2    0          3       0      0          3    0    0     0   0  0   0      return product + handle.get();
         49    6    1         35       0      0          0    0    0     7   5  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  // ref: http://teem.sourceforge.net/nrrd/format.html#encoding
          .    .    .          .       .      .          .    .    .     .   .  .   .  template<typename T>
          .    .    .          .       .      .          .    .    .     .   .  .   .  constexpr bool isValidNrrdEncodedType(){
          .    .    .          .       .      .          .    .    .     .   .  .   .      return std::is_integral_v<T> ||
          .    .    .          .       .      .          .    .    .     .   .  .   .             std::is_floating_point_v<T>;
          .    .    .          .       .      .          .    .    .     .   .  .   .  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
-- line 299 ----------------------------------------
-- line 300 ----------------------------------------
          .    .    .          .       .      .          .    .    .     .   .  .   .  template<typename T, typename = std::enable_if_t<isValidNrrdEncodedType<T>()>>
          .    .    .          .       .      .          .    .    .     .   .  .   .  T DecodeBytesSpcialized(const std::string_view& data, const std::size_t index){
          .    .    .          .       .      .          .    .    .     .   .  .   .      T value;
          .    .    .          .       .      .          .    .    .     .   .  .   .      std::memcpy(&value, (data.data() + index), sizeof(T));
          .    .    .          .       .      .          .    .    .     .   .  .   .      return value;
          .    .    .          .       .      .          .    .    .     .   .  .   .  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  template <>
 46,317,450    5    1          0       0      0 23,158,725    0    0     0   0  0   0  std::uint8_t DecodeBytesSpcialized<std::uint8_t>(const std::string_view& data, std::size_t index){
          .    .    .          .       .      .          .    .    .     .   .  .   .      // static cast is faster
 46,317,450    0    0 23,158,725 120,650 15,393  7,719,575    0    0     0   0  0   0      return static_cast<std::uint8_t>(data[index]);
 15,439,150    0    0 15,439,150       0      0          0    0    0     0   0  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  template <typename T>
 54,037,025    3    1          0       0      0 30,878,300    0    0     0   0  0   0  constexpr inline const T& Clamp(const T& min, const T& val, const T& max){
 77,195,750    3    1 23,158,725       6      0 15,439,150    8    0     0   0  0   0      return std::max(min, std::min(max, val));
 15,439,150    0    0 15,439,150       0      0          0    0    0     0   0  0   0  }
          .    .    .          .       .      .          .    .    .     .   .  .   .  
          .    .    .          .       .      .          .    .    .     .   .  .   .  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr          D1mr    DLmr   Dw          D1mw DLmw Bc         Bcm    Bi Bim 
--------------------------------------------------------------------------------
1,430,189,008 7,390  307 528,080,100 123,635 15,412 311,579,747  170   29 39,172,621 81,147  7   7  events annotated

